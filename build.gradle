/*
 * Bearsampp Module PHP - Pure Gradle Build
 *
 * This is a pure Gradle build configuration that replaces the legacy Ant build system.
 * All build logic has been converted to native Gradle tasks.
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release                            - Interactive release (prompts for version)
 *   gradle release -PbundleVersion=8.3.15     - Non-interactive release
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 *   gradle verify                             - Verify build environment
 */

plugins {
    id 'base'
}

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'php')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath
    buildPropertiesFile = file('build.properties').absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'php')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'bins')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // External build base path precedence: build.properties (build.path) -> env(BEARSAMPP_BUILD_PATH) -> default <root>/bearsampp-build
    def buildPathFromProps = (buildProps.getProperty('build.path', '') ?: '').trim()
    def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
    def defaultBuildPath = "${rootDir}/bearsampp-build"
    buildBasePath = buildPathFromProps ? buildPathFromProps : (buildPathFromEnv ? buildPathFromEnv : defaultBuildPath)

    // Shared external tmp tree (MySQL pattern)
    buildTmpPath = file("${buildBasePath}/tmp").absolutePath
    bundleTmpPrepPath = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}").absolutePath
    bundleTmpBuildPath = file("${buildTmpPath}/bundles_build/${bundleType}/${bundleName}").absolutePath
    bundleTmpSrcPath = file("${buildTmpPath}/bundles_src").absolutePath
    bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}").absolutePath
    bundleTmpExtractPath = file("${buildTmpPath}/extract/${bundleName}").absolutePath

    // Final external output path for archives (e.g., bearsampp-build/bins/php/2025.10.31)
    moduleBuildOutputPath = file("${buildBasePath}/${bundleType}/${bundleName}/${bundleRelease}").absolutePath

    // PHP-specific paths (static in repo)
    phpExtPath = file("${projectDir}/ext").absolutePath
    pearInstallPath = file("${projectDir}/pear").absolutePath
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    logger.warn("Dev path not found: ${ext.devPath}. Some tasks may not work correctly.")
}

// Configure repositories for dependencies
repositories {
    mavenCentral()
}

// ============================================================================
// GRADLE NATIVE TASKS - Pure Gradle Implementation
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    // Capture values at configuration time to avoid deprecation warnings
    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                  Bearsampp Module PHP - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          Build Base:   ${buildBasePath}
          Output Dir:   ${moduleBuildOutputPath}
          Tmp Root:     ${buildTmpPath}
          Tmp Prep:     ${bundleTmpPrepPath}
          Tmp Build:    ${bundleTmpBuildPath}
          Tmp Src:      ${bundleTmpSrcPath}
          Downloads:    ${bundleTmpDownloadPath}
          Extract:      ${bundleTmpExtractPath}
          Gradle Build: ${buildDir}
          Distributions:${buildDir}/distributions
          PHP Ext:      ${phpExtPath}
          PEAR Install: ${pearInstallPath}

        Java:
          Version:      ${JavaVersion.current()}
          Home:         ${System.getProperty('java.home')}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification and validation tasks

        Quick Start:
          gradle tasks                          - List all available tasks
          gradle info                           - Show this information
          gradle release                        - Interactive release build
          gradle release -PbundleVersion=8.3.15 - Non-interactive release
          gradle clean                          - Clean build artifacts
          gradle verify                         - Verify build environment
          gradle listExtensions                 - List PHP extensions to build
        """.stripIndent()
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
            println "Cleaned: ${buildDir}"
        }

        // Clean temporary directories
        def tmpDir = file(buildTmpPath)
        if (tmpDir.exists()) {
            delete tmpDir
            println "Cleaned: ${tmpDir}"
        }

        println "[SUCCESS] Build artifacts cleaned"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-php..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()

        // Check PHP-specific directories
        checks['pear directory'] = file(pearInstallPath).exists()
        checks['pear-install.bat'] = file("${pearInstallPath}/pear-install.bat").exists()

        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release                        - Interactive release"
            println "  gradle release -PbundleVersion=8.3.15 - Non-interactive release"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// Task: Validate architecture of DLL files
tasks.register('validateDllArchitecture') {
    group = 'verification'
    description = 'Validate DLL architecture (64-bit check)'

    doLast {
        def dllFile = project.findProperty('dllFile')
        if (!dllFile) {
            throw new GradleException("Please specify -PdllFile=<path> to validate")
        }

        def dll = file(dllFile)
        if (!dll.exists()) {
            throw new GradleException("DLL file not found: ${dllFile}")
        }

        println "Validating architecture for: ${dll.name}"

        def outputFile = file("${buildTmpPath}/sigcheck_output.txt")
        outputFile.parentFile.mkdirs()

        def psCommand = """
try {
    \$bytes = [System.IO.File]::ReadAllBytes('${dll.absolutePath}');
    \$peOffset = [System.BitConverter]::ToInt32(\$bytes, 60);
    \$machineType = [System.BitConverter]::ToUInt16(\$bytes, \$peOffset + 4);
    if (\$machineType -eq 0x8664) {
        Write-Output 'MachineType: 64-bit'
    } elseif (\$machineType -eq 0x014c) {
        Write-Output 'MachineType: 32-bit'
    } else {
        Write-Output 'MachineType: Unknown'
    }
} catch {
    Write-Output 'MachineType: Error'
}
""".trim()

        def result = exec {
            executable 'powershell.exe'
            args '-NoLogo', '-NoProfile', '-Command', psCommand
            standardOutput = new ByteArrayOutputStream()
            ignoreExitValue = true
        }

        def output = result.standardOutput.toString().trim()
        println output

        if (!output.contains('64-bit')) {
            throw new GradleException("DLL ${dll.name} is not 64-bit architecture. Build halted.")
        }

        println "[SUCCESS] DLL is 64-bit compatible"
    }
}

// Task: Download file helper
def downloadFile(String url, File destDir) {
    def fileName = url.tokenize('/').last()
    def destFile = new File(destDir, fileName)

    if (!destFile.exists()) {
        println "Downloading: ${url}"
        destFile.parentFile.mkdirs()

        new URL(url).withInputStream { input ->
            destFile.withOutputStream { output ->
                output << input
            }
        }
        println "Downloaded to: ${destFile}"
    } else {
        println "Already exists: ${destFile}"
    }

    return destFile
}

// Task: Extract archive helper
def extractArchive(File archive, File destDir) {
    destDir.mkdirs()

    if (archive.name.endsWith('.zip')) {
        copy {
            from zipTree(archive)
            into destDir
        }
    } else if (archive.name.endsWith('.7z')) {
        exec {
            executable '7z'
            args 'x', archive.absolutePath, "-o${destDir.absolutePath}", '-y'
        }
    }

    println "Extracted to: ${destDir}"
}

// Helper methods for version discovery and selection
def findAvailableVersions = {
    def binDir = new File(projectDir, 'bin')
    def archivedDir = new File(projectDir, 'bin/archived')
    def versions = [] as List<String>

    if (binDir.exists()) {
        versions.addAll(
            (binDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    if (archivedDir.exists()) {
        versions.addAll(
            (archivedDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    return versions.unique()
}

def latestVersion = { List<String> versions ->
    if (versions.isEmpty()) return null
    // Compare numerically by dot-separated parts
    return versions.max { a, b ->
        def pa = a.split('\\.').collect { it as int }
        def pb = b.split('\\.').collect { it as int }
        def len = Math.max(pa.size(), pb.size())
        for (int i = 0; i < len; i++) {
            def ai = i < pa.size() ? pa[i] : 0
            def bi = i < pb.size() ? pb[i] : 0
            if (ai != bi) return ai <=> bi
        }
        return 0
    }
}

// Task: Resolve version (interactive by default; supports -PbundleVersion and '*')
tasks.register('resolveVersion') {
    group = 'build'
    description = 'Resolve bundleVersion (interactive by default, or use -PbundleVersion=*,<ver>)'
    // Interactive capability is not compatible with configuration cache
    notCompatibleWithConfigurationCache("interactive prompt for bundleVersion when property is absent")

    doLast {
        def supplied = project.findProperty('bundleVersion') as String
        // Aggregate both bin/ and bin/archived/ and display with location tags
        def all = findAvailableVersions().sort { a, b ->
            def pa = a.split('\\.').collect { it as int }
            def pb = b.split('\\.').collect { it as int }
            for (int i=0; i<Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }
        def inBin = new File(projectDir, 'bin').exists() ? (new File(projectDir, 'bin').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []
        def inArchived = new File(projectDir, 'bin/archived').exists() ? (new File(projectDir, 'bin/archived').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        String resolved
        if (supplied) {
            if (supplied == '*') {
                resolved = latestVersion(all)
                if (!resolved) {
                    throw new GradleException("No versions found under bin/ to resolve latest from.")
                }
                println "Resolved latest version: ${resolved}"
            } else {
                resolved = supplied
            }
        } else {
            println "=".multiply(70)
            println "Available ${bundleName} versions (index, version, location):"
            println "-".multiply(70)
            all.eachWithIndex { v, idx ->
                def indexStr = String.format('%2d', idx + 1)
                def tag = inBin.contains(v) && inArchived.contains(v) ? '[bin + bin/archived]' : (inBin.contains(v) ? '[bin]' : (inArchived.contains(v) ? '[bin/archived]' : '[unknown]'))
                println "  ${indexStr}. ${v.padRight(12)} ${tag}"
            }
            println "-".multiply(70)
            print "\nEnter version to build (index or version string): "
            System.out.flush()
            def reader = new BufferedReader(new InputStreamReader(System.in))
            def input = reader.readLine()?.trim()
            if (!input) {
                throw new GradleException("No version specified")
            }
            if (input.isInteger()) {
                def idx = input.toInteger()
                if (idx < 1 || idx > all.size()) {
                    throw new GradleException("Invalid index: ${input}. Choose 1..${all.size()} or enter a version string.")
                }
                resolved = all[idx - 1]
            } else {
                resolved = input
            }
        }

        // Validate existence in bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${resolved}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${resolved}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                def listing = all.collect { "  - ${it}" }.join('\n')
                throw new GradleException("Bundle version not found in bin/ or bin/archived/: ${bundleName}${resolved}\n\nAvailable versions:\n${listing}")
            }
        }

        // Expose to subsequent tasks as extra property (readable via project.findProperty)
        project.ext.set('bundleVersion', resolved)
        println "\nSelected version: ${resolved}\n"
    }
}

// Task: Main release task (interactive by default; non‑interactive when -PbundleVersion provided)
tasks.register('release') {
    group = 'build'
    description = 'Build release package (interactive by default; -PbundleVersion=* or X.Y.Z for non-interactive)'

    // Wire task graph instead of executing tasks programmatically
    dependsOn 'resolveVersion', 'packageRelease'
}

// Task: Interactive release (explicitly prompts; not compatible with configuration cache)
tasks.register('releaseInteractive') {
    group = 'build'
    description = 'Interactive release (prompts for version)'
    dependsOn 'packageRelease'

    // Interactive tasks are not compatible with configuration cache
    notCompatibleWithConfigurationCache("interactive prompt for bundleVersion")

    doFirst {
        def binDir = new File(projectDir, 'bin')
        def inBin = binDir.exists() ? binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .collect { it.name.replace(bundleName, '') } : []
        def archivedDir = new File(projectDir, 'bin/archived')
        def inArchived = archivedDir.exists() ? archivedDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .collect { it.name.replace(bundleName, '') } : []
        def all = (inBin + inArchived).toSet().toList().sort { a, b ->
                def pa = a.split('\\.').collect { it as int }
                def pb = b.split('\\.').collect { it as int }
                for (int i=0; i<Math.max(pa.size(), pb.size()); i++) {
                    def ai = i < pa.size() ? pa[i] : 0
                    def bi = i < pb.size() ? pb[i] : 0
                    if (ai != bi) return ai <=> bi
                }
                return 0
            }

        println "=".multiply(70)
        println "Available ${bundleName} versions (index, version, location):"
        println "-".multiply(70)
        all.eachWithIndex { v, idx ->
            def indexStr = String.format('%2d', idx + 1)
            def tag = inBin.contains(v) && inArchived.contains(v) ? '[bin + bin/archived]' : (inBin.contains(v) ? '[bin]' : (inArchived.contains(v) ? '[bin/archived]' : '[unknown]'))
            println "  ${indexStr}. ${v.padRight(12)} ${tag}"
        }
        println "-".multiply(70)

        print "\nEnter version to build (index or version string): "
        System.out.flush()

        def reader = new BufferedReader(new InputStreamReader(System.in))
        def input = reader.readLine()?.trim()
        if (!input) {
            throw new GradleException("No version specified")
        }

        def versionToBuild
        if (input.isInteger()) {
            def idx = input.toInteger()
            if (idx < 1 || idx > all.size()) {
                throw new GradleException("Invalid index: ${input}. Choose 1..${all.size()} or enter a version string.")
            }
            versionToBuild = all[idx - 1]
        } else {
            versionToBuild = input
        }

        // Validate selected version exists in bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (!archivedPath.exists()) {
                def listing = all.collect { "  - ${it}" }.join('\n')
                throw new GradleException("Bundle version not found in bin/ or bin/archived/: ${bundleName}${versionToBuild}\n\nAvailable versions:\n${listing}")
            }
        }

        // Expose version to dependent tasks
        project.ext.set('bundleVersion', versionToBuild)
        println "\nBuilding release for ${bundleName} version ${versionToBuild}...\n"
    }
}

// Task: Actual release build logic
tasks.register('releaseBuild') {
    group = 'build'
    description = 'Execute the release build process'
    dependsOn 'resolveVersion'

    doLast {
        def versionToBuild = project.findProperty('bundleVersion')
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Resolve source folder from bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                throw new GradleException("Bundle folder not found in bin/ or bin/archived/: ${bundleName}${versionToBuild}")
            }
        }

        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        println "Processing bundle: ${bundleFolder}"
        println "Version: ${bundleVersion}"

        // Prepare PHP directory
        def phpPrepPath = new File(bundleTmpPrepPath, bundleFolder)
        delete phpPrepPath
        phpPrepPath.mkdirs()

        println "Preparation path: ${phpPrepPath}"

        // Copy base PHP files
        println "Copying base PHP files..."
        copy {
            from bundlePath
            into phpPrepPath
            exclude 'dev/**', 'extras/**', 'PEAR/**', '*.reg', 'install.txt',
                    'go-pear.bat', 'news.txt', 'php.gif', 'php.ini*', 'snapshot.txt'
        }

        // Process extensions if exts.properties exists
        def extsFile = new File(bundlePath, 'exts.properties')
        if (extsFile.exists()) {
            println "Processing extensions..."
            processExtensions(extsFile, phpPrepPath)
        }

        // Process PEAR if pear.properties exists
        def pearFile = new File(bundlePath, 'pear.properties')
        if (pearFile.exists()) {
            println "Processing PEAR installation..."
            processPear(pearFile, phpPrepPath)
        }

        // Process dependencies if deps.properties exists
        def depsFile = new File(bundlePath, 'deps.properties')
        if (depsFile.exists()) {
            println "Processing dependencies..."
            processDependencies(depsFile, phpPrepPath)
        }

        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println "Output: ${phpPrepPath}"
        println "=".multiply(70)
    }
}

// Task: Package release as archive (ensures the version folder is included at archive root)
// - Creates: bearsampp-build/bins/php/<bundle.release>/bearsampp-php-<version>-<bundle.release>.<format>
// - The archive contains the top-level folder: <bundleName><version>/ ...
// Provider resolves version from either -PbundleVersion or value set by resolveVersion in project.ext
def bundleVersionProvider = providers.provider {
    def fromProp = project.findProperty('bundleVersion') as String
    if (fromProp) return fromProp
    def extras = project.extensions.extraProperties
    return extras.has('bundleVersion') ? (extras.get('bundleVersion') as String) : null
}
def externalOutputDir = file("${moduleBuildOutputPath}")

// Guard task: ensure bundleVersion is resolved before any packaging runs
tasks.register('assertVersionResolved') {
    group = 'build'
    description = 'Fail fast if bundleVersion was not resolved by resolveVersion'
    dependsOn 'resolveVersion'
    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set. Run 'gradle resolveVersion' or invoke 'gradle release -PbundleVersion=<'*'|X.Y.Z>'")
        }
    }
}

// 7z packager (pure Gradle via Exec; requires 7-Zip in PATH)
tasks.register('packageRelease7z', Exec) {
    group = 'build'
    description = 'Package release into a .7z archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doFirst {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared php directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        externalOutputDir.mkdirs()
        def archiveName = "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.7z"
        def archiveFile = new File(externalOutputDir, archiveName)

        // Create archive so that php{version}/ is at the root
        workingDir prepRoot
        executable '7z'
        args 'a', '-t7z', archiveFile.absolutePath, bundleFolder

        println "Packaging (7z): ${archiveFile}"
        println "Included root folder: ${bundleFolder}/"
    }
}

// Zip packager (Gradle native Zip task) — used if bundle.format != 7z
tasks.register('packageReleaseZip', Zip) {
    group = 'build'
    description = 'Package release into a .zip archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doFirst {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared php directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        archiveFileName.set("bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.zip")
        destinationDirectory.set(externalOutputDir)

        // Include the version folder as the top-level entry in the archive
        from(prepRoot) {
            include "${bundleFolder}/**"
        }

        println "Packaging (zip): ${new File(externalOutputDir, archiveFileName.get()).absolutePath}"
        println "Included root folder: ${bundleFolder}/"
    }
}

// Dispatcher task that chooses packager based on bundle.format (configured without executing tasks programmatically)
def archiveFormat = (bundleFormat ?: '7z').toLowerCase()
tasks.register('packageRelease') {
    group = 'build'
    description = 'Package release into archive (7z or zip) including the version folder at root'
    // Ensure the preparation step runs before packaging
    dependsOn 'resolveVersion', 'releaseBuild', 'assertVersionResolved'
    // Select the concrete packager at configuration time based on build.properties
    dependsOn archiveFormat == '7z' ? 'packageRelease7z' : 'packageReleaseZip'
}

// Task: Generate hash files for the produced archive (.md5, .sha1, .sha256, .sha512)
tasks.register('generateHashes') {
    group = 'build'
    description = 'Generate hash sidecar files for the packaged archive'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }
        def extFormat = (bundleFormat ?: '7z').toLowerCase()
        def archive = new File(externalOutputDir, "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.${extFormat}")
        if (!archive.exists()) {
            throw new GradleException("Archive not found for hashing: ${archive}")
        }

        def calcHash = { File f, String algorithm ->
            def digest = java.security.MessageDigest.getInstance(algorithm)
            f.withInputStream { stream ->
                byte[] buf = new byte[8192]
                int r
                while ((r = stream.read(buf)) != -1) {
                    digest.update(buf, 0, r)
                }
            }
            digest.digest().collect { String.format('%02x', it) }.join('')
        }

        def writeHash = { String algo, String ext ->
            def h = calcHash(archive, algo)
            def out = new File(archive.absolutePath + ".${ext}")
            out.text = "${h} ${archive.name}\n"
            println "Created: ${out.name}"
        }

        writeHash('MD5', 'md5')
        writeHash('SHA-1', 'sha1')
        writeHash('SHA-256', 'sha256')
        writeHash('SHA-512', 'sha512')
    }
}

// Ensure hashes are generated after packaging during release
tasks.named('release') {
    finalizedBy 'generateHashes'
}

// Helper: Process PHP extensions
def processExtensions(File extsFile, File phpPrepPath) {
    def exts = new Properties()
    extsFile.withInputStream { exts.load(it) }

    def extensionsText = new StringBuilder()
    def tmpExtFile = file("${buildTmpPath}/php_extensions.tmp")
    tmpExtFile.parentFile.mkdirs()
    tmpExtFile.text = ""

    exts.each { key, url ->
        def extName = key.toString().replace('phpexts.', '')
        println "  Processing extension: ${extName}"

        // Download extension
        def downloadDir = file("${buildTmpPath}/downloads/ext/${extName}")
        def extArchive = downloadFile(url.toString(), downloadDir)

        // Extract if needed
        def extDir = downloadDir
        if (extArchive.name.endsWith('.zip') || extArchive.name.endsWith('.7z')) {
            extDir = file("${downloadDir}/extracted")
            extractArchive(extArchive, extDir)
        }

        // Find the main DLL
        def mainDll = null
        extDir.eachFileRecurse { file ->
            if (file.name == "php_${extName}.dll") {
                mainDll = file
            }
        }

        if (!mainDll) {
            throw new GradleException("Main DLL not found for extension: ${extName}")
        }

        // Validate architecture
        println "    Validating architecture..."
        validateDllArchitecture(mainDll)

        // Copy extension DLL
        def destDll = new File(phpPrepPath, "ext/php_${extName}.dll")
        destDll.parentFile.mkdirs()
        copy {
            from mainDll
            into destDll.parentFile
        }
        println "    Copied: ${destDll.name}"

        // Handle special cases (e.g., imagick)
        if (extName == 'imagick') {
            def imagickDir = new File(phpPrepPath, 'imagick')
            imagickDir.mkdirs()
            copy {
                from extDir
                into imagickDir
                include 'CORE_*.dll'
            }
        }

        // Add to extensions list (except xdebug)
        if (extName != 'xdebug') {
            extensionsText.append("extension=${extName}\n")
        }
    }

    // Update php.ini with extensions
    def phpIniTemplate = new File(phpPrepPath.parentFile.parentFile.parentFile, "bin/${phpPrepPath.name}/php.ini")
    if (phpIniTemplate.exists()) {
        def phpIniContent = phpIniTemplate.text
        phpIniContent = phpIniContent.replace('@PHP_EXTENSIONS@', extensionsText.toString())

        def phpIniDest = new File(phpPrepPath, 'php.ini')
        phpIniDest.text = phpIniContent
        println "  Updated php.ini with extensions"
    }
}

// Helper: Validate DLL architecture
def validateDllArchitecture(File dll) {
    def psCommand = """
try {
    \$bytes = [System.IO.File]::ReadAllBytes('${dll.absolutePath.replace('\\', '\\\\')}');
    \$peOffset = [System.BitConverter]::ToInt32(\$bytes, 60);
    \$machineType = [System.BitConverter]::ToUInt16(\$bytes, \$peOffset + 4);
    if (\$machineType -eq 0x8664) {
        Write-Output '64-bit'
    } elseif (\$machineType -eq 0x014c) {
        Write-Output '32-bit'
    } else {
        Write-Output 'Unknown'
    }
} catch {
    Write-Output 'Error'
}
""".trim()

    def output = new ByteArrayOutputStream()
    exec {
        executable 'powershell.exe'
        args '-NoLogo', '-NoProfile', '-Command', psCommand
        standardOutput = output
        ignoreExitValue = false
    }

    def result = output.toString().trim()
    if (!result.contains('64-bit')) {
        throw new GradleException("DLL ${dll.name} is not 64-bit architecture")
    }
}

// Helper: Process PEAR installation
def processPear(File pearFile, File phpPrepPath) {
    def pear = new Properties()
    pearFile.withInputStream { pear.load(it) }

    // Copy pear-install scripts
    def pearInstallDir = new File(phpPrepPath, 'pear-install')
    copy {
        from pearInstallPath
        into pearInstallDir
    }

    // Download PEAR phar
    def pearUrl = pear.getProperty('phppear.pear')
    def pearPhar = downloadFile(pearUrl, pearInstallDir)

    copy {
        from pearPhar
        into pearInstallDir
        rename { 'install-pear-nozlib.phar' }
    }

    // Execute PEAR installation
    println "  Installing PEAR..."
    exec {
        executable 'cmd'
        args '/c', 'pear-install.bat'
        workingDir pearInstallDir
    }

    // Cleanup
    delete pearInstallDir
    println "  PEAR installation completed"
}

// Helper: Process dependencies
def processDependencies(File depsFile, File phpPrepPath) {
    def deps = new Properties()
    depsFile.withInputStream { deps.load(it) }

    deps.each { key, url ->
        def depName = key.toString().replace('phpdeps.', '')
        println "  Processing dependency: ${depName}"

        // Download dependency
        def downloadDir = file("${buildTmpPath}/downloads/dep/${depName}")
        def depArchive = downloadFile(url.toString(), downloadDir)

        // Extract if needed
        def depDir = downloadDir
        if (depArchive.name.endsWith('.zip') || depArchive.name.endsWith('.7z')) {
            depDir = file("${downloadDir}/extracted")
            extractArchive(depArchive, depDir)
        }

        // Handle special cases
        if (depName == 'imagemagick') {
            def imagickDir = new File(phpPrepPath, 'imagick')
            imagickDir.mkdirs()
            copy {
                from depDir
                into imagickDir
                include '*.exe', '*.dll'
            }
            println "    Copied ImageMagick files"
        }
    }
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        def releasesFile = file('releases.properties')
        if (!releasesFile.exists()) {
            println "releases.properties not found"
            return
        }

        def releases = new Properties()
        releasesFile.withInputStream { releases.load(it) }

        println "\nAvailable PHP Releases:"
        println "-".multiply(80)
        releases.sort { it.key }.each { version, url ->
            println "  ${version.padRight(10)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${releases.size()}"
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        def archivedDir = file("${projectDir}/bin/archived")

        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        def inBin = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []

        def inArchived = archivedDir.exists() ? (archivedDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        def allVersions = (inBin + inArchived).toSet().toList().sort { a, b ->
            def pa = a.split('\\.').collect { it as int }
            def pb = b.split('\\.').collect { it as int }
            for (int i = 0; i < Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }

        println "\nAvailable ${bundleName} versions (index, version, location):"
        println "-".multiply(60)
        allVersions.eachWithIndex { v, idx ->
            def tag
            def inBinFlag = inBin.contains(v)
            def inArchivedFlag = inArchived.contains(v)
            if (inBinFlag && inArchivedFlag) {
                tag = "[bin + bin/archived]"
            } else if (inBinFlag) {
                tag = "[bin]"
            } else if (inArchivedFlag) {
                tag = "[bin/archived]"
            } else {
                tag = "[unknown]"
            }
            def indexStr = String.format('%2d', idx + 1)
            println "  ${indexStr}. ${v.padRight(12)} ${tag}"
        }
        println "-".multiply(60)
        println "Total versions: ${allVersions.size()}"
        if (!allVersions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${allVersions.last()}"
        }
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println "Validating build.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: List PHP extensions to be built
tasks.register('listExtensions') {
    group = 'help'
    description = 'List PHP extensions configured in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for PHP extension configurations..."
        println "=".multiply(80)

        def foundExtensions = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def extsFile = new File(versionDir, 'exts.properties')
                if (extsFile.exists()) {
                    foundExtensions = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def exts = new Properties()
                    extsFile.withInputStream { exts.load(it) }

                    exts.sort { it.key }.each { ext, url ->
                        def extName = ext.toString().replace('phpexts.', '')
                        println "  ${extName.padRight(20)} -> ${url}"
                    }
                }
            }

        if (!foundExtensions) {
            println "No extension configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: List PEAR configurations
tasks.register('listPearConfig') {
    group = 'help'
    description = 'List PEAR configurations in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for PEAR configurations..."
        println "=".multiply(80)

        def foundPear = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def pearFile = new File(versionDir, 'pear.properties')
                if (pearFile.exists()) {
                    foundPear = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def pear = new Properties()
                    pearFile.withInputStream { pear.load(it) }

                    pear.each { key, value ->
                        println "  ${key.toString().padRight(20)} -> ${value}"
                    }
                }
            }

        if (!foundPear) {
            println "No PEAR configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: List dependencies
tasks.register('listDependencies') {
    group = 'help'
    description = 'List dependencies configured in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for dependency configurations..."
        println "=".multiply(80)

        def foundDeps = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def depsFile = new File(versionDir, 'deps.properties')
                if (depsFile.exists()) {
                    foundDeps = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def deps = new Properties()
                    depsFile.withInputStream { deps.load(it) }

                    deps.sort { it.key }.each { dep, url ->
                        def depName = dep.toString().replace('phpdeps.', '')
                        println "  ${depName.padRight(20)} -> ${url}"
                    }
                }
            }

        if (!foundDeps) {
            println "No dependency configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: Show PHP-specific build information
tasks.register('phpInfo') {
    group = 'help'
    description = 'Display PHP-specific build information'

    doLast {
        println """
        ================================================================
                  PHP Module Build - Specific Information
        ================================================================

        This module includes special build processes for:

        1. PHP Extensions (exts.properties)
           - Downloads and integrates PHP extensions
           - Validates extensions with architecture check
           - Automatically updates php.ini

        2. PEAR Installation (pear.properties)
           - Installs PEAR package manager
           - Configures PEAR for the PHP version

        3. Dependencies (deps.properties)
           - Downloads required dependencies (e.g., ImageMagick)
           - Integrates dependencies into the build

        4. Architecture Verification
           - Verifies digital signatures of extensions
           - Ensures 64-bit compatibility

        Configuration Files:
          - exts.properties    : PHP extensions to include
          - pear.properties    : PEAR installation config
          - deps.properties    : External dependencies

        Useful Commands:
          gradle listExtensions     - Show configured extensions
          gradle listPearConfig     - Show PEAR configurations
          gradle listDependencies   - Show dependencies
          gradle validateDllArchitecture -PdllFile=<path> - Verify DLL
        """.stripIndent()
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module PHP - Pure Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
