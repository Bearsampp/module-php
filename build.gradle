/*
 * Bearsampp Module PHP - Pure Gradle Build
 *
 * This is a pure Gradle build configuration that replaces the legacy Ant build system.
 * All build logic has been converted to native Gradle tasks.
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release                            - Interactive release (prompts for version)
 *   gradle release -PbundleVersion=8.3.15     - Non-interactive release
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 *   gradle verify                             - Verify build environment
 */

plugins {
    id 'base'
}

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'php')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath
    buildPropertiesFile = file('build.properties').absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'php')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'bins')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // External build base path precedence: build.properties (build.path) -> env(BEARSAMPP_BUILD_PATH) -> default <root>/bearsampp-build
    def buildPathFromProps = (buildProps.getProperty('build.path', '') ?: '').trim()
    def buildPathFromEnv = System.getenv('BEARSAMPP_BUILD_PATH') ?: ''
    def defaultBuildPath = "${rootDir}/bearsampp-build"
    buildBasePath = buildPathFromProps ? buildPathFromProps : (buildPathFromEnv ? buildPathFromEnv : defaultBuildPath)

    // Shared external tmp tree (MySQL pattern)
    buildTmpPath = file("${buildBasePath}/tmp").absolutePath
    bundleTmpPrepPath = file("${buildTmpPath}/bundles_prep/${bundleType}/${bundleName}").absolutePath
    bundleTmpBuildPath = file("${buildTmpPath}/bundles_build/${bundleType}/${bundleName}").absolutePath
    bundleTmpSrcPath = file("${buildTmpPath}/bundles_src").absolutePath
    bundleTmpDownloadPath = file("${buildTmpPath}/downloads/${bundleName}").absolutePath
    bundleTmpExtractPath = file("${buildTmpPath}/extract/${bundleName}").absolutePath

    // Final external output path for archives (e.g., bearsampp-build/bins/php/2025.10.31)
    moduleBuildOutputPath = file("${buildBasePath}/${bundleType}/${bundleName}/${bundleRelease}").absolutePath

    // PHP-specific paths (static in repo)
    phpExtPath = file("${projectDir}/ext").absolutePath
    pearInstallPath = file("${projectDir}/pear").absolutePath
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    logger.warn("Dev path not found: ${ext.devPath}. Some tasks may not work correctly.")
}

// Configure repositories for dependencies
repositories {
    mavenCentral()
}

// ============================================================================
// GRADLE NATIVE TASKS - Pure Gradle Implementation
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    // Capture values at configuration time to avoid deprecation warnings
    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                  Bearsampp Module PHP - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          Build Base:   ${buildBasePath}
          Output Dir:   ${moduleBuildOutputPath}
          Tmp Root:     ${buildTmpPath}
          Tmp Prep:     ${bundleTmpPrepPath}
          Tmp Build:    ${bundleTmpBuildPath}
          Tmp Src:      ${bundleTmpSrcPath}
          Downloads:    ${bundleTmpDownloadPath}
          Extract:      ${bundleTmpExtractPath}
          PHP Ext:      ${phpExtPath}
          PEAR Install: ${pearInstallPath}

        Java:
          Version:      ${JavaVersion.current()}
          Home:         ${System.getProperty('java.home')}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification and validation tasks

        Quick Start:
          gradle tasks                          - List all available tasks
          gradle info                           - Show this information
          gradle release                        - Interactive release build
          gradle release -PbundleVersion=8.3.15 - Non-interactive release
          gradle clean                          - Clean build artifacts
          gradle verify                         - Verify build environment
          gradle listExtensions                 - List PHP extensions to build
        """.stripIndent()
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files (preserves bundles_build)'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
            println "Cleaned: ${buildDir}"
        }

        // Clean temporary directories (but preserve bundles_build)
        def tmpDir = file(buildTmpPath)
        if (tmpDir.exists()) {
            // Delete specific subdirectories, but keep bundles_build
            def dirsToClean = ['bundles_prep', 'downloads', 'extract', 'bundles_src']
            dirsToClean.each { dirName ->
                def dir = file("${buildTmpPath}/${dirName}")
                if (dir.exists()) {
                    delete dir
                    println "Cleaned: ${dir}"
                }
            }
            
            // Clean Gradle-specific temp files
            def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
            if (gradleBundleVersion.exists()) {
                delete gradleBundleVersion
                println "Cleaned: ${gradleBundleVersion.name}"
            }

            def phpExtensionsTmp = file("${buildTmpPath}/php_extensions.tmp")
            if (phpExtensionsTmp.exists()) {
                delete phpExtensionsTmp
                println "Cleaned: ${phpExtensionsTmp.name}"
            }
            
            println "Preserved: ${file(bundleTmpBuildPath)}"
        }

        println "[SUCCESS] Build artifacts cleaned (bundles_build preserved)"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-php..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()

        // Check PHP-specific directories
        checks['pear directory'] = file(pearInstallPath).exists()
        checks['pear-install.bat'] = file("${pearInstallPath}/pear-install.bat").exists()

        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release                        - Interactive release"
            println "  gradle release -PbundleVersion=8.3.15 - Non-interactive release"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// Task: Validate architecture of DLL files
tasks.register('validateDllArchitecture') {
    group = 'verification'
    description = 'Validate DLL architecture (64-bit check)'

    doLast {
        def dllFile = project.findProperty('dllFile')
        if (!dllFile) {
            throw new GradleException("Please specify -PdllFile=<path> to validate")
        }

        def dll = file(dllFile)
        if (!dll.exists()) {
            throw new GradleException("DLL file not found: ${dllFile}")
        }

        println "Validating architecture for: ${dll.name}"

        def outputFile = file("${buildTmpPath}/sigcheck_output.txt")
        outputFile.parentFile.mkdirs()

        def psCommand = """
try {
    \$bytes = [System.IO.File]::ReadAllBytes('${dll.absolutePath}');
    \$peOffset = [System.BitConverter]::ToInt32(\$bytes, 60);
    \$machineType = [System.BitConverter]::ToUInt16(\$bytes, \$peOffset + 4);
    if (\$machineType -eq 0x8664) {
        Write-Output 'MachineType: 64-bit'
    } elseif (\$machineType -eq 0x014c) {
        Write-Output 'MachineType: 32-bit'
    } else {
        Write-Output 'MachineType: Unknown'
    }
} catch {
    Write-Output 'MachineType: Error'
}
""".trim()

        def result = exec {
            executable 'powershell.exe'
            args '-NoLogo', '-NoProfile', '-Command', psCommand
            standardOutput = new ByteArrayOutputStream()
            ignoreExitValue = true
        }

        def output = result.standardOutput.toString().trim()
        println output

        if (!output.contains('64-bit')) {
            throw new GradleException("DLL ${dll.name} is not 64-bit architecture. Build halted.")
        }

        println "[SUCCESS] DLL is 64-bit compatible"
    }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

// Helper function to find 7-Zip executable
def find7ZipExecutable() {
    // Check environment variable
    def sevenZipHome = System.getenv('7Z_HOME')
    if (sevenZipHome) {
        def exe = file("${sevenZipHome}/7z.exe")
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Check common installation paths
    def commonPaths = [
        'C:/Program Files/7-Zip/7z.exe',
        'C:/Program Files (x86)/7-Zip/7z.exe',
        'D:/Program Files/7-Zip/7z.exe',
        'D:/Program Files (x86)/7-Zip/7z.exe'
    ]

    for (path in commonPaths) {
        def exe = file(path)
        if (exe.exists()) {
            return exe.absolutePath
        }
    }

    // Try to find in PATH
    try {
        def process = ['where', '7z.exe'].execute()
        process.waitFor()
        if (process.exitValue() == 0) {
            def output = process.text.trim()
            if (output) {
                return output.split('\n')[0].trim()
            }
        }
    } catch (Exception e) {
        // Ignore
    }

    return null
}

// Helper function to calculate hash
def calculateHash(File file, String algorithm) {
    def digest = java.security.MessageDigest.getInstance(algorithm)
    file.withInputStream { stream ->
        def buffer = new byte[8192]
        def bytesRead
        while ((bytesRead = stream.read(buffer)) != -1) {
            digest.update(buffer, 0, bytesRead)
        }
    }
    return digest.digest().collect { String.format('%02x', it) }.join('')
}

// Helper function to generate hash files
def generateHashFiles(File file) {
    if (!file.exists()) {
        throw new GradleException("File not found for hashing: ${file}")
    }

    // Generate MD5
    def md5File = new File("${file.absolutePath}.md5")
    def md5Hash = calculateHash(file, 'MD5')
    md5File.text = "${md5Hash} ${file.name}\n"
    println "  Created: ${md5File.name}"

    // Generate SHA1
    def sha1File = new File("${file.absolutePath}.sha1")
    def sha1Hash = calculateHash(file, 'SHA-1')
    sha1File.text = "${sha1Hash} ${file.name}\n"
    println "  Created: ${sha1File.name}"

    // Generate SHA256
    def sha256File = new File("${file.absolutePath}.sha256")
    def sha256Hash = calculateHash(file, 'SHA-256')
    sha256File.text = "${sha256Hash} ${file.name}\n"
    println "  Created: ${sha256File.name}"

    // Generate SHA512
    def sha512File = new File("${file.absolutePath}.sha512")
    def sha512Hash = calculateHash(file, 'SHA-512')
    sha512File.text = "${sha512Hash} ${file.name}\n"
    println "  Created: ${sha512File.name}"
}

// Helper: Fetch php.properties from modules-untouched repository
def fetchModulesUntouchedProperties() {
    def propsUrl = "https://raw.githubusercontent.com/Bearsampp/modules-untouched/main/modules/php.properties"

    println "Fetching php.properties from modules-untouched repository..."
    println "  URL: ${propsUrl}"

    def tempFile = file("${bundleTmpDownloadPath}/php-untouched.properties")
    tempFile.parentFile.mkdirs()

    try {
        // Download using Java URL connection
        new URL(propsUrl).withInputStream { input ->
            tempFile.withOutputStream { output ->
                output << input
            }
        }

        def props = new Properties()
        tempFile.withInputStream { props.load(it) }

        println "  [OK] Successfully loaded ${props.size()} versions from modules-untouched"
        return props
    } catch (Exception e) {
        println "  [WARN] Could not fetch php.properties from modules-untouched: ${e.message}"
        println "  Will fall back to standard URL format if needed"
        return null
    }
}

// Helper: Download PHP binaries from modules-untouched repository
def downloadFromModulesUntouched(String version, File destDir) {
    def untouchedProps = fetchModulesUntouchedProperties()
    def untouchedUrl = null

    if (untouchedProps) {
        untouchedUrl = untouchedProps.getProperty(version)
        if (untouchedUrl) {
            println "Found version ${version} in modules-untouched php.properties"
            println "Downloading from:"
            println "  ${untouchedUrl}"
        } else {
            println "Version ${version} not found in modules-untouched php.properties"
            println "Attempting to construct URL based on standard format..."
            // Fallback to constructed URL
            untouchedUrl = "https://windows.php.net/downloads/releases/php-${version}-Win32-vs16-x64.zip"
            println "  ${untouchedUrl}"
        }
    } else {
        println "Could not fetch php.properties, using standard URL format..."
        // Fallback to constructed URL
        untouchedUrl = "https://windows.php.net/downloads/releases/php-${version}-Win32-vs16-x64.zip"
        println "  ${untouchedUrl}"
    }

    // Determine filename from URL
    def filename = untouchedUrl.substring(untouchedUrl.lastIndexOf('/') + 1)
    def downloadDir = file(bundleTmpDownloadPath)
    downloadDir.mkdirs()

    def downloadedFile = file("${downloadDir}/${filename}")

    // Download if not already present
    if (!downloadedFile.exists()) {
        println "  Downloading..."
        new URL(untouchedUrl).withInputStream { input ->
            downloadedFile.withOutputStream { output ->
                output << input
            }
        }
        println "  [OK] Downloaded: ${downloadedFile.name}"
    } else {
        println "  [OK] Already downloaded: ${downloadedFile.name}"
    }

    return downloadedFile
}

// Helper: Download and extract PHP binaries
def downloadAndExtractPhp(String version, File destDir) {
    // Download from modules-untouched
    def downloadedFile = downloadFromModulesUntouched(version, destDir)

    // Extract the archive
    def extractDir = file(bundleTmpExtractPath)
    extractDir.mkdirs()
    println "  Extracting archive..."
    def extractPath = file("${extractDir}/${version}")
    if (extractPath.exists()) {
        delete extractPath
    }
    extractPath.mkdirs()

    // Extract using Gradle's zipTree
    copy {
        from zipTree(downloadedFile)
        into extractPath
    }

    // Find the PHP directory (it might be nested)
    def phpDir = findPhpDirectory(extractPath)
    if (!phpDir) {
        throw new GradleException("Could not find PHP directory in extracted archive")
    }

    println "  Extracted to: ${phpDir}"
    return phpDir
}

// Helper: Find PHP directory containing php.exe
def findPhpDirectory(File searchDir) {
    // Case 1: Check if php.exe is directly in this directory
    def phpExe = new File(searchDir, 'php.exe')
    if (phpExe.exists()) {
        return searchDir
    }

    // Case 2: Recursively search for a directory containing php.exe
    File found = null
    def stack = new ArrayDeque<File>()
    stack.push(searchDir)

    while (!stack.isEmpty() && !found) {
        def current = stack.pop()
        def children = current.listFiles()
        if (children) {
            for (def child : children) {
                if (child.isDirectory()) {
                    def exe = new File(child, 'php.exe')
                    if (exe.exists()) {
                        found = child
                        break
                    }
                    stack.push(child)
                }
            }
        }
    }

    return found
}

// Task: Download file helper
def downloadFile(String url, File destDir) {
    if (!url) {
        throw new GradleException("Download URL is null or empty")
    }

    def fileName = url.tokenize('/').last()
    def destFile = new File(destDir, fileName)

    if (!destFile.exists()) {
        println "Downloading: ${url}"
        destFile.parentFile.mkdirs()

        new URL(url).withInputStream { input ->
            destFile.withOutputStream { output ->
                output << input
            }
        }
        println "Downloaded to: ${destFile}"
    } else {
        println "Already exists: ${destFile}"
    }

    return destFile
}

// Task: Extract archive helper
def extractArchive(File archive, File destDir) {
    destDir.mkdirs()

    if (archive.name.endsWith('.zip')) {
        copy {
            from zipTree(archive)
            into destDir
        }
    } else if (archive.name.endsWith('.7z')) {
        // Find 7z executable
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("7-Zip not found. Cannot extract .7z archive: ${archive.name}")
        }

        // Extract using ProcessBuilder
        def command = [
            sevenZipExe,
            'x',
            archive.absolutePath,
            "-o${destDir.absolutePath}",
            '-y'
        ]

        def process = new ProcessBuilder(command as String[])
            .redirectErrorStream(true)
            .start()

        def output = new StringBuilder()
        process.inputStream.eachLine { line ->
            output.append(line).append('\n')
        }

        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7-Zip extraction failed with exit code: ${exitCode}\nOutput: ${output}")
        }
    }

    println "Extracted to: ${destDir}"
}

// Helper methods for version discovery and selection
def findAvailableVersions = {
    def binDir = new File(projectDir, 'bin')
    def archivedDir = new File(projectDir, 'bin/archived')
    def versions = [] as List<String>

    if (binDir.exists()) {
        versions.addAll(
            (binDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    if (archivedDir.exists()) {
        versions.addAll(
            (archivedDir.listFiles() ?: [])
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                .collect { it.name.replace(bundleName, '') }
        )
    }

    return versions.unique()
}

def latestVersion = { List<String> versions ->
    if (versions.isEmpty()) return null
    // Compare numerically by dot-separated parts
    return versions.max { a, b ->
        def pa = a.split('\\.').collect { it as int }
        def pb = b.split('\\.').collect { it as int }
        def len = Math.max(pa.size(), pb.size())
        for (int i = 0; i < len; i++) {
            def ai = i < pa.size() ? pa[i] : 0
            def bi = i < pb.size() ? pb[i] : 0
            if (ai != bi) return ai <=> bi
        }
        return 0
    }
}

// Task: Resolve version (interactive by default; supports -PbundleVersion and '*')
tasks.register('resolveVersion') {
    group = 'build'
    description = 'Resolve bundleVersion (interactive by default, or use -PbundleVersion=*,<ver>)'

    // Capture properties at configuration time
    def versionProperty = project.findProperty('bundleVersion')
    def projectDirPath = projectDir
    def bundleNameValue = bundleName

    doLast {
        def supplied = versionProperty as String
        // Aggregate both bin/ and bin/archived/ and display with location tags
        def all = findAvailableVersions().sort { a, b ->
            def pa = a.split('\\.').collect { it as int }
            def pb = b.split('\\.').collect { it as int }
            for (int i=0; i<Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }
        def inBin = new File(projectDir, 'bin').exists() ? (new File(projectDir, 'bin').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []
        def inArchived = new File(projectDir, 'bin/archived').exists() ? (new File(projectDir, 'bin/archived').listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        String resolved
        if (supplied) {
            if (supplied == '*') {
                resolved = latestVersion(all)
                if (!resolved) {
                    throw new GradleException("No versions found under bin/ to resolve latest from.")
                }
                println "Resolved latest version: ${resolved}"
            } else {
                resolved = supplied
            }
        } else {
            println "=".multiply(70)
            println "Available ${bundleName} versions (index, version, location):"
            println "-".multiply(70)
            all.eachWithIndex { v, idx ->
                def indexStr = String.format('%2d', idx + 1)
                def tag = inBin.contains(v) && inArchived.contains(v) ? '[bin + bin/archived]' : (inBin.contains(v) ? '[bin]' : (inArchived.contains(v) ? '[bin/archived]' : '[unknown]'))
                println "  ${indexStr}. ${v.padRight(12)} ${tag}"
            }
            println "-".multiply(70)
            print "\nEnter version to build (index or version string): "
            System.out.flush()
            def reader = new BufferedReader(new InputStreamReader(System.in))
            def input = reader.readLine()?.trim()
            if (!input) {
                throw new GradleException("No version specified")
            }
            if (input.isInteger()) {
                def idx = input.toInteger()
                if (idx < 1 || idx > all.size()) {
                    throw new GradleException("Invalid index: ${input}. Choose 1..${all.size()} or enter a version string.")
                }
                resolved = all[idx - 1]
            } else {
                resolved = input
            }
        }

        // Validate existence in bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${resolved}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${resolved}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                def listing = all.collect { "  - ${it}" }.join('\n')
                throw new GradleException("Bundle version not found in bin/ or bin/archived/: ${bundleName}${resolved}\n\nAvailable versions:\n${listing}")
            }
        }

        // Expose to subsequent tasks as extra property
        // Store in a shared location that can be accessed by other tasks
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        propsFile.parentFile.mkdirs()
        propsFile.text = resolved
        println "\nSelected version: ${resolved}\n"
    }
}

// Task: Main release task (interactive by default; nonâ€‘interactive when -PbundleVersion provided)
tasks.register('release') {
    group = 'build'
    description = 'Build release package (interactive by default; -PbundleVersion=* or X.Y.Z for non-interactive)'

    // Always clean before building to ensure fresh build
    // Note: fetch task is NOT included by default - run it separately if you want to update dependencies
    dependsOn 'clean', 'resolveVersion', 'packageRelease'
}

// Task: Interactive release (explicitly prompts)
tasks.register('releaseInteractive') {
    group = 'build'
    description = 'Interactive release (prompts for version)'
    dependsOn 'packageRelease'

    doFirst {
        def binDir = new File(projectDir, 'bin')
        def inBin = binDir.exists() ? binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .collect { it.name.replace(bundleName, '') } : []
        def archivedDir = new File(projectDir, 'bin/archived')
        def inArchived = archivedDir.exists() ? archivedDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .collect { it.name.replace(bundleName, '') } : []
        def all = (inBin + inArchived).toSet().toList().sort { a, b ->
                def pa = a.split('\\.').collect { it as int }
                def pb = b.split('\\.').collect { it as int }
                for (int i=0; i<Math.max(pa.size(), pb.size()); i++) {
                    def ai = i < pa.size() ? pa[i] : 0
                    def bi = i < pb.size() ? pb[i] : 0
                    if (ai != bi) return ai <=> bi
                }
                return 0
            }

        println "=".multiply(70)
        println "Available ${bundleName} versions (index, version, location):"
        println "-".multiply(70)
        all.eachWithIndex { v, idx ->
            def indexStr = String.format('%2d', idx + 1)
            def tag = inBin.contains(v) && inArchived.contains(v) ? '[bin + bin/archived]' : (inBin.contains(v) ? '[bin]' : (inArchived.contains(v) ? '[bin/archived]' : '[unknown]'))
            println "  ${indexStr}. ${v.padRight(12)} ${tag}"
        }
        println "-".multiply(70)

        print "\nEnter version to build (index or version string): "
        System.out.flush()

        def reader = new BufferedReader(new InputStreamReader(System.in))
        def input = reader.readLine()?.trim()
        if (!input) {
            throw new GradleException("No version specified")
        }

        def versionToBuild
        if (input.isInteger()) {
            def idx = input.toInteger()
            if (idx < 1 || idx > all.size()) {
                throw new GradleException("Invalid index: ${input}. Choose 1..${all.size()} or enter a version string.")
            }
            versionToBuild = all[idx - 1]
        } else {
            versionToBuild = input
        }

        // Validate selected version exists in bin/ or bin/archived/
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (!archivedPath.exists()) {
                def listing = all.collect { "  - ${it}" }.join('\n')
                throw new GradleException("Bundle version not found in bin/ or bin/archived/: ${bundleName}${versionToBuild}\n\nAvailable versions:\n${listing}")
            }
        }

        // Expose version to dependent tasks
        project.ext.set('bundleVersion', versionToBuild)
        println "\nBuilding release for ${bundleName} version ${versionToBuild}...\n"
    }
}

// Task: Fetch and update dependencies from modules-untouched
// ============================================================================
// FETCH TASK - Fetch and update dependencies from modules-untouched
// ============================================================================

// Task: Fetch and update dependencies from modules-untouched
tasks.register('fetch') {
    group = 'build'
    description = 'Fetch latest dependencies and update configuration files'
    dependsOn 'resolveVersion'

    // Capture version at configuration time
    def versionProvider = providers.provider {
        def fromProp = project.findProperty('bundleVersion') as String
        if (fromProp) return fromProp
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        if (propsFile.exists()) {
            return propsFile.text.trim()
        }
        return null
    }

    doLast {
        // ANSI color codes for terminal output
        def ANSI_RESET = "\u001B[0m"
        def ANSI_GREEN = "\u001B[32m"
        def ANSI_YELLOW = "\u001B[33m"
        def ANSI_BLUE = "\u001B[36m"
        def ANSI_RED = "\u001B[31m"

        // Helper to print colored messages
        def printOk = { String msg ->
            println "${ANSI_GREEN}[OK]${ANSI_RESET} ${msg}"
        }

        def printWarn = { String msg ->
            println "${ANSI_YELLOW}[WARN]${ANSI_RESET} ${msg}"
        }

        def printError = { String msg ->
            println "${ANSI_RED}[ERROR]${ANSI_RESET} ${msg}"
        }

        def printInfo = { String msg ->
            println "${ANSI_BLUE}[INFO]${ANSI_RESET} ${msg}"
        }

        def versionToBuild = versionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        println "=" * 70
        printInfo "Fetching latest dependencies for PHP ${versionToBuild}..."
        println "=" * 70
        println ""

        // Step 1: Update build.properties with today's date
        printInfo "Step 1: Updating build.properties with current date..."
        def buildPropsFile = file('build.properties')
        def buildPropsContent = buildPropsFile.text
        def today = new Date().format('yyyy.MM.dd')
        buildPropsContent = buildPropsContent.replaceAll(/bundle\.release\s*=\s*\d{4}\.\d{2}\.\d{2}/, "bundle.release = ${today}")
        buildPropsFile.text = buildPropsContent
        printOk "Updated bundle.release to ${today}"
        println ""

        // Extract major.minor version (e.g., 8.4 from 8.4.15)
        def versionParts = versionToBuild.split('\\.')
        def majorMinor = "${versionParts[0]}.${versionParts[1]}"
        printInfo "PHP Version: ${versionToBuild} (major.minor: ${majorMinor})"
        println ""

        // Resolve bundle path
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                throw new GradleException("Bundle folder not found: ${bundleName}${versionToBuild}")
            }
        }

        // Step 2: Get release tag from php.properties
        printInfo "Step 2: Getting release tag from php.properties..."

        def untouchedProps = fetchModulesUntouchedProperties()
        if (!untouchedProps) {
            throw new GradleException("Could not fetch php.properties from modules-untouched")
        }

        def phpUrl = untouchedProps.getProperty(versionToBuild)
        if (!phpUrl) {
            throw new GradleException("PHP version ${versionToBuild} not found in php.properties")
        }

        printOk "Found PHP ${versionToBuild} in php.properties"
        printInfo "URL: ${phpUrl}"

        // Extract release tag from URL (e.g., php-2025.12.7 from .../releases/download/php-2025.12.7/...)
        def releaseTagMatcher = phpUrl =~ /\/releases\/download\/(php-\d{4}\.\d{1,2}\.\d{1,2})\//
        if (!releaseTagMatcher.find()) {
            throw new GradleException("Could not extract release tag from PHP URL: ${phpUrl}")
        }

        def releaseTag = releaseTagMatcher.group(1)
        printOk "Extracted release tag: ${releaseTag}"

        // Fetch release assets from GitHub API
        printInfo "Fetching release assets from GitHub..."

        def githubToken = findProperty('github.token') ?: System.getenv('GH_PAT')
        def apiUrl = "https://api.github.com/repos/Bearsampp/modules-untouched/releases/tags/${releaseTag}"

        def connection = new URL(apiUrl).openConnection()
        if (githubToken) {
            connection.setRequestProperty("Authorization", "token ${githubToken}")
        }
        connection.setRequestProperty("Accept", "application/vnd.github.v3+json")

        def response = connection.inputStream.text
        def slurper = new groovy.json.JsonSlurper()
        def release = slurper.parseText(response)

        def assets = release.assets

        printOk "Release: ${releaseTag}"
        printOk "Assets: ${assets.size()} files"
        println ""

        // Step 3: Search for dependencies with flexible patterns
        printInfo "Step 3: Searching for dependencies..."

        def updates = [:]
        def warnings = []

        // Helper to find asset by pattern
        def findAsset = { pattern ->
            return assets.find { asset -> asset.name =~ pattern }
        }

        // Helper to construct URL
        def constructUrl = { assetName ->
            return "https://github.com/Bearsampp/modules-untouched/releases/download/${releaseTag}/${assetName}"
        }

        // Search for ImageMagick
        def imagickAsset = findAsset(/ImageMagick-.*-portable-Q16-HDRI-x64\.7z/)
        if (imagickAsset) {
            updates['imagemagick'] = constructUrl(imagickAsset.name)
            printOk "Found ImageMagick: ${imagickAsset.name}"
        } else {
            warnings.add("ImageMagick not found")
        }

        // Search for php_imagick - try multiple patterns
        def phpImagickAsset = findAsset(/php_imagick-.*-${majorMinor}-.*\.(zip|dll)/) ?:
                              findAsset(/php-${majorMinor}\.x_imagick\.dll/) ?:
                              findAsset(/php_imagick-.*-${versionParts[0]}\.${versionParts[1]}.*\.(zip|dll)/)
        if (phpImagickAsset) {
            updates['imagick'] = constructUrl(phpImagickAsset.name)
            printOk "Found php_imagick: ${phpImagickAsset.name}"
        } else {
            warnings.add("php_imagick for PHP ${majorMinor} not found")
        }

        // Search for memcache - try multiple patterns
        def memcacheAsset = findAsset(/php_memcache-.*-${majorMinor}-.*\.(zip|dll)/) ?:
                           findAsset(/php-${majorMinor}\.x_memcache\.dll/) ?:
                           findAsset(/php_memcache-.*-${versionParts[0]}\.${versionParts[1]}.*\.(zip|dll)/)
        if (memcacheAsset) {
            updates['memcache'] = constructUrl(memcacheAsset.name)
            printOk "Found memcache: ${memcacheAsset.name}"
        } else {
            warnings.add("memcache for PHP ${majorMinor} not found")
        }

        // Search for xdebug - try multiple patterns
        def xdebugAsset = findAsset(/php_xdebug-.*-${majorMinor}-.*\.(dll|zip)/) ?:
                         findAsset(/php-${majorMinor}\.x_xdebug\.dll/) ?:
                         findAsset(/php_xdebug-.*-${versionParts[0]}\.${versionParts[1]}.*\.(dll|zip)/)
        if (xdebugAsset) {
            updates['xdebug'] = constructUrl(xdebugAsset.name)
            printOk "Found xdebug: ${xdebugAsset.name}"
        } else {
            warnings.add("xdebug for PHP ${majorMinor} not found")
        }

        // Search for PEAR (pearweb_phars-*.tgz format)
        def pearAsset = findAsset(/pearweb_phars-.*\.tgz/)
        if (pearAsset) {
            updates['pear'] = constructUrl(pearAsset.name)
            printOk "Found PEAR: ${pearAsset.name}"
        } else {
            warnings.add("PEAR not found")
        }

        println ""

        if (!warnings.isEmpty()) {
            printWarn "Warnings:"
            warnings.each { warning ->
                printWarn "  ${warning}"
            }
            println ""
        }

        // Step 4: Update configuration files
        printInfo "Step 4: Updating configuration files..."

        def filesUpdated = 0

        // Helper to update properties file
        def updatePropertiesFile = { File file, Map<String, String> updatesMap ->
            if (!file.exists()) {
                printWarn "File not found: ${file.name}"
                return false
            }

            def lines = file.readLines()
            def updated = false

            updatesMap.each { key, value ->
                // Don't escape colons in URLs - keep them readable
                def escapedValue = value.replace('\\', '\\\\')

                for (int i = 0; i < lines.size(); i++) {
                    def line = lines[i]
                    if (line.trim().startsWith('#') || line.trim().isEmpty()) {
                        continue
                    }

                    // Match key with optional spaces around = or :
                    if (line =~ /^\s*${java.util.regex.Pattern.quote(key)}\s*[=:]/) {
                        lines[i] = "${key}=${escapedValue}"
                        updated = true
                        break
                    }
                }
            }

            if (updated) {
                file.text = lines.join('\n') + '\n'
            }

            return updated
        }

        // Update bearsampp.conf
        def bearsamppConf = new File(bundlePath, 'bearsampp.conf')
        if (bearsamppConf.exists()) {
            def content = bearsamppConf.text
            def oldContent = content
            content = content.replaceAll(/phpVersion\s*=\s*"[^"]*"/, "phpVersion = \"${versionToBuild}\"")
            if (content != oldContent) {
                bearsamppConf.text = content
                printOk "bearsampp.conf (phpVersion updated)"
                filesUpdated++
            }
        }

        // Update deps.properties
        def depsProps = new File(bundlePath, 'deps.properties')
        if (depsProps.exists() && updates.containsKey('imagemagick')) {
            if (updatePropertiesFile(depsProps, [imagemagick: updates['imagemagick']])) {
                printOk "deps.properties (imagemagick updated)"
                filesUpdated++
            }
        }

        // Update exts.properties
        def extsProps = new File(bundlePath, 'exts.properties')
        if (extsProps.exists()) {
            def extsUpdates = [:]
            if (updates.containsKey('imagick')) extsUpdates['imagick'] = updates['imagick']
            if (updates.containsKey('memcache')) extsUpdates['memcache'] = updates['memcache']
            if (updates.containsKey('xdebug')) extsUpdates['xdebug'] = updates['xdebug']

            if (!extsUpdates.isEmpty()) {
                if (updatePropertiesFile(extsProps, extsUpdates)) {
                    printOk "exts.properties (${extsUpdates.size()} extensions updated)"
                    filesUpdated++
                }
            }
        }

        // Update pear.properties
        def pearProps = new File(bundlePath, 'pear.properties')
        if (pearProps.exists() && updates.containsKey('pear')) {
            if (updatePropertiesFile(pearProps, [pear: updates['pear']])) {
                printOk "pear.properties (pear updated)"
                filesUpdated++
            }
        }

        // Update php.ini
        def phpIni = new File(bundlePath, 'php.ini')
        if (phpIni.exists()) {
            def content = phpIni.text
            def oldContent = content

            content = content.replaceAll(
                /include_path\s*=\s*"\.;~BEARSAMPP_LIN_PATH~\/bin\/php\/php[^\/]*\/pear\/pear"/,
                "include_path=\".;~BEARSAMPP_LIN_PATH~/bin/php/php${versionToBuild}/pear/pear\""
            )

            content = content.replaceAll(
                /extension_dir\s*=\s*"~BEARSAMPP_LIN_PATH~\/bin\/php\/php[^\/]*\/ext"/,
                "extension_dir = \"~BEARSAMPP_LIN_PATH~/bin/php/php${versionToBuild}/ext\""
            )

            content = content.replaceAll(
                /zend_extension\s*=\s*"~BEARSAMPP_LIN_PATH~\/bin\/php\/php[^\/]*\/ext\/php_opcache\.dll"/,
                "zend_extension = \"~BEARSAMPP_LIN_PATH~/bin/php/php${versionToBuild}/ext/php_opcache.dll\""
            )

            if (content != oldContent) {
                phpIni.text = content
                printOk "php.ini (3 paths updated)"
                filesUpdated++
            }
        }

        println ""
        println "=" * 70
        printOk "Configuration update complete!"
        println "=" * 70
        println ""
        printInfo "Summary:"
        printInfo "  - PHP Version: ${versionToBuild}"
        printInfo "  - Bundle Release: ${today}"
        printInfo "  - Release Tag: ${releaseTag}"
        printInfo "  - Files Updated: ${filesUpdated}"
        printInfo "  - Dependencies Found: ${updates.size()}"
        if (!warnings.isEmpty()) {
            printInfo "  - Warnings: ${warnings.size()}"
        }
        println ""
    }
}


// Task: Actual release build logic
tasks.register('releaseBuild') {
    group = 'build'
    description = 'Execute the release build process'
    dependsOn 'resolveVersion', 'fetch'

    // Capture version at configuration time to avoid deprecation warnings
    def versionProvider = providers.provider {
        def fromProp = project.findProperty('bundleVersion') as String
        if (fromProp) return fromProp
        // Read from file written by resolveVersion task
        def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
        if (propsFile.exists()) {
            return propsFile.text.trim()
        }
        return null
    }

    doLast {
        def versionToBuild = versionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }


        // Resolve config folder from bin/ or bin/archived/ (contains exts.properties, pear.properties, etc.)
        def bundlePath = new File(projectDir, "bin/${bundleName}${versionToBuild}")
        if (!bundlePath.exists()) {
            def archivedPath = new File(projectDir, "bin/archived/${bundleName}${versionToBuild}")
            if (archivedPath.exists()) {
                bundlePath = archivedPath
            } else {
                throw new GradleException("Bundle folder not found in bin/ or bin/archived/: ${bundleName}${versionToBuild}")
            }
        }

        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        println "Processing bundle: ${bundleFolder}"
        println "Version: ${bundleVersion}"

        // Determine source paths for PHP binaries
        def bundleSrcDest = bundlePath
        def bundleSrcFinal = bundleSrcDest

        // Check if php.exe exists in bin/ directory (it won't - only config files are there)
        def phpExe = file("${bundleSrcFinal}/php.exe")
        if (!phpExe.exists()) {
            // PHP binaries not found in bin/ - check if already downloaded to bearsampp-build/tmp
            def tmpExtractPath = file("${bundleTmpExtractPath}/${bundleVersion}")
            def tmpPhpDir = findPhpDirectory(tmpExtractPath)

            if (tmpPhpDir && tmpPhpDir.exists()) {
                println "Using cached PHP binaries from bearsampp-build/tmp"
                bundleSrcFinal = tmpPhpDir
            } else {
                // Download and extract to bearsampp-build/tmp
                println ""
                println "PHP binaries not found"
                println "Downloading PHP ${bundleVersion}..."
                println ""

                try {
                    // Download and extract to bearsampp-build/tmp
                    bundleSrcFinal = downloadAndExtractPhp(bundleVersion, file(bundleTmpExtractPath))
                } catch (Exception e) {
                    throw new GradleException("""
                        Failed to download PHP binaries: ${e.message}

                        You can manually download and extract PHP binaries to:
                          ${bundleSrcDest}/

                        Or check that version ${bundleVersion} exists in modules-untouched php.properties
                    """.stripIndent())
                }
            }
        }

        // Verify php.exe exists
        phpExe = file("${bundleSrcFinal}/php.exe")
        if (!phpExe.exists()) {
            throw new GradleException("php.exe not found at ${phpExe}")
        }

        println "Source folder: ${bundleSrcFinal}"
        println ""

        // Prepare PHP directory
        def phpPrepPath = new File(bundleTmpPrepPath, bundleFolder)
        delete phpPrepPath
        phpPrepPath.mkdirs()

        println "Preparation path: ${phpPrepPath}"

        // Copy base PHP binaries
        println "Copying base PHP files..."
        copy {
            from bundleSrcFinal
            into phpPrepPath
        }

        // Copy config files from bin/ directory (bearsampp.conf, php.ini, etc.)
        println "Copying configuration files..."
        copy {
            from bundleSrcDest
            into phpPrepPath
            exclude 'deps/**'
        }

        // Process extensions if exts.properties exists
        def extsFile = new File(bundlePath, 'exts.properties')
        if (extsFile.exists()) {
            println "Processing extensions..."
            processExtensions(extsFile, phpPrepPath)
        }

        // Process PEAR if pear.properties exists
        def pearFile = new File(bundlePath, 'pear.properties')
        if (pearFile.exists()) {
            println "Processing PEAR installation..."
            processPear(pearFile, phpPrepPath)
        }

        // Process dependencies if deps.properties exists
        def depsFile = new File(bundlePath, 'deps.properties')
        if (depsFile.exists()) {
            println "Processing dependencies..."
            processDependencies(depsFile, phpPrepPath)
        }

        // Copy prepared files to bundles_build directory for persistence
        def phpBuildPath = new File(bundleTmpBuildPath, bundleFolder)
        println ""
        println "Copying to build output directory..."
        delete phpBuildPath
        phpBuildPath.mkdirs()
        copy {
            from phpPrepPath
            into phpBuildPath
        }
        println "Build output: ${phpBuildPath}"

        // Note: We don't need to store these paths anymore since they're printed above
    }
}

// Task: Package release as archive (ensures the version folder is included at archive root)
// - Creates: bearsampp-build/bins/php/<bundle.release>/bearsampp-php-<version>-<bundle.release>.<format>
// - The archive contains the top-level folder: <bundleName><version>/ ...
// Provider resolves version from either -PbundleVersion or value set by resolveVersion
def bundleVersionProvider = providers.provider {
    def fromProp = project.findProperty('bundleVersion') as String
    if (fromProp) return fromProp
    // Read from file written by resolveVersion task
    def propsFile = file("${buildTmpPath}/.gradle-bundleVersion")
    if (propsFile.exists()) {
        return propsFile.text.trim()
    }
    return null
}
def externalOutputDir = file("${moduleBuildOutputPath}")

// Guard task: ensure bundleVersion is resolved before any packaging runs
tasks.register('assertVersionResolved') {
    group = 'build'
    description = 'Fail fast if bundleVersion was not resolved by resolveVersion'
    dependsOn 'resolveVersion'
    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set. Run 'gradle resolveVersion' or invoke 'gradle release -PbundleVersion=<'*'|X.Y.Z>'")
        }
    }
}

// 7z packager (uses ProcessBuilder pattern from MySQL for better control)
tasks.register('packageRelease7z') {
    group = 'build'
    description = 'Package release into a .7z archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared php directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        externalOutputDir.mkdirs()
        def archiveName = "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.7z"
        def archiveFile = new File(externalOutputDir, archiveName)

        // Delete existing archive if present
        if (archiveFile.exists()) {
            delete archiveFile
        }

        println "Packaging (7z): ${archiveFile}"
        println "Included root folder: ${bundleFolder}/"

        // Find 7z executable
        def sevenZipExe = find7ZipExecutable()
        if (!sevenZipExe) {
            throw new GradleException("""
                7-Zip not found. Please install 7-Zip or set 7Z_HOME environment variable.

                Download from: https://www.7-zip.org/
                Or set 7Z_HOME to your 7-Zip installation directory.
            """.stripIndent())
        }

        // Create 7z archive using ProcessBuilder (MySQL pattern)
        // To ensure the archive contains the version folder (e.g., php8.3.15) at the root,
        // we run 7-Zip from the parent directory and add the folder name explicitly.
        def command = [
            sevenZipExe,
            'a',
            '-t7z',
            archiveFile.absolutePath.toString(),
            bundleFolder
        ]

        def process = new ProcessBuilder(command as String[])
            .directory(prepRoot)
            .redirectErrorStream(true)
            .start()

        process.inputStream.eachLine { line ->
            if (line.trim()) println "  ${line}"
        }

        def exitCode = process.waitFor()
        if (exitCode != 0) {
            throw new GradleException("7-Zip compression failed with exit code: ${exitCode}")
        }

        println "Archive created: ${archiveFile}"
    }
}

// Zip packager (Gradle native Zip task) â€” used if bundle.format != 7z
tasks.register('packageReleaseZip', Zip) {
    group = 'build'
    description = 'Package release into a .zip archive (includes version folder at root)'
    // Ensure version is resolved and preparation executed before packaging
    dependsOn 'assertVersionResolved', 'releaseBuild'

    doFirst {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        // Ensure prepared php directory exists
        def bundleFolder = "${bundleName}${versionToBuild}"
        def prepRoot = file("${bundleTmpPrepPath}")
        def srcDir = new File(prepRoot, bundleFolder)
        if (!srcDir.exists()) {
            throw new GradleException("Prepared folder not found: ${srcDir}. Run releaseBuild first.")
        }

        archiveFileName.set("bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.zip")
        destinationDirectory.set(externalOutputDir)

        // Include the version folder as the top-level entry in the archive
        from(prepRoot) {
            include "${bundleFolder}/**"
        }

        println "Packaging (zip): ${new File(externalOutputDir, archiveFileName.get()).absolutePath}"
        println "Included root folder: ${bundleFolder}/"
    }
}

// Dispatcher task that chooses packager based on bundle.format (configured without executing tasks programmatically)
def archiveFormat = (bundleFormat ?: '7z').toLowerCase()
tasks.register('packageRelease') {
    group = 'build'
    description = 'Package release into archive (7z or zip) including the version folder at root'
    // Ensure the preparation step runs before packaging
    dependsOn 'resolveVersion', 'releaseBuild', 'assertVersionResolved'
    // Select the concrete packager at configuration time based on build.properties
    dependsOn archiveFormat == '7z' ? 'packageRelease7z' : 'packageReleaseZip'
}

// Task: Generate hash files for the produced archive (.md5, .sha1, .sha256, .sha512)
tasks.register('generateHashes') {
    group = 'build'
    description = 'Generate hash sidecar files for the packaged archive'

    doLast {
        def versionToBuild = bundleVersionProvider.getOrNull()
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }
        def extFormat = (bundleFormat ?: '7z').toLowerCase()
        def archive = new File(externalOutputDir, "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}.${extFormat}")
        if (!archive.exists()) {
            throw new GradleException("Archive not found for hashing: ${archive}")
        }

        def calcHash = { File f, String algorithm ->
            def digest = java.security.MessageDigest.getInstance(algorithm)
            f.withInputStream { stream ->
                byte[] buf = new byte[8192]
                int r
                while ((r = stream.read(buf)) != -1) {
                    digest.update(buf, 0, r)
                }
            }
            digest.digest().collect { String.format('%02x', it) }.join('')
        }

        def writeHash = { String algo, String ext ->
            def h = calcHash(archive, algo)
            def out = new File(archive.absolutePath + ".${ext}")
            out.text = "${h} ${archive.name}\n"
            println "Created: ${out.name}"
        }

        writeHash('MD5', 'md5')
        writeHash('SHA-1', 'sha1')
        writeHash('SHA-256', 'sha256')
        writeHash('SHA-512', 'sha512')

        // Print final success message
        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println ""
        println "Build directories:"
        println "  Temp prep:   ${file("${bundleTmpPrepPath}/${bundleName}${versionToBuild}").absolutePath}"
        println "  Build output: ${file("${bundleTmpBuildPath}/${bundleName}${versionToBuild}").absolutePath}"
        println ""
        println "Archive: ${new File(externalOutputDir, "bearsampp-${bundleName}-${versionToBuild}-${bundleRelease}").absolutePath}.${extFormat}"
        println "=".multiply(70)
    }
}

// Ensure hashes are generated after packaging during release, and cleanup temp files
tasks.named('release') {
    finalizedBy 'generateHashes', 'cleanupTempFiles'
}

// Task: Cleanup temporary Gradle-specific files after build
tasks.register('cleanupTempFiles') {
    group = 'build'
    description = 'Cleanup temporary Gradle-specific files after build'

    doLast {
        // Clean Gradle-specific temp files
        def gradleBundleVersion = file("${buildTmpPath}/.gradle-bundleVersion")
        if (gradleBundleVersion.exists()) {
            delete gradleBundleVersion
            println "Cleaned up: ${gradleBundleVersion.name}"
        }

        def phpExtensionsTmp = file("${buildTmpPath}/php_extensions.tmp")
        if (phpExtensionsTmp.exists()) {
            delete phpExtensionsTmp
            println "Cleaned up: ${phpExtensionsTmp.name}"
        }
    }
}

// Helper: Process PHP extensions
def processExtensions(File extsFile, File phpPrepPath) {
    def exts = new Properties()
    extsFile.withInputStream { exts.load(it) }

    def extensionsText = new StringBuilder()
    def tmpExtFile = file("${buildTmpPath}/php_extensions.tmp")
    tmpExtFile.parentFile.mkdirs()
    tmpExtFile.text = ""

    exts.each { key, url ->
        def extName = key.toString().replace('phpexts.', '')
        println "  Processing extension: ${extName}"

        // Download extension
        def downloadDir = file("${buildTmpPath}/downloads/ext/${extName}")
        def extArchive = downloadFile(url.toString(), downloadDir)

        // Handle different download types
        def mainDll = null
        def extDir = downloadDir

        if (extArchive.name.endsWith('.dll')) {
            // Direct DLL download - use it directly
            mainDll = extArchive
        } else if (extArchive.name.endsWith('.zip') || extArchive.name.endsWith('.7z')) {
            // Archive - extract and find DLL
            extDir = file("${downloadDir}/extracted")
            extractArchive(extArchive, extDir)

            // Find the main DLL in extracted files (recursively search all subdirectories)
            // For xdebug, the DLL name includes version info (e.g., php_xdebug-3.5.0-8.3-ts-vs16-x86_64.dll)
            extDir.eachFileRecurse { file ->
                if (file.isFile()) {
                    // Match exact name or versioned name (for xdebug)
                    if (file.name == "php_${extName}.dll" || 
                        (extName == 'xdebug' && file.name =~ /php_xdebug-.*\.dll/)) {
                        mainDll = file
                    }
                }
            }
            
            if (!mainDll) {
                println "    ERROR: Could not find php_${extName}.dll in extracted archive"
            }
        } else {
            throw new GradleException("Unsupported extension file type for ${extName}: ${extArchive.name}")
        }

        if (!mainDll) {
            throw new GradleException("Main DLL not found for extension: ${extName}. Downloaded file: ${extArchive.name}")
        }

        // Validate architecture
        println "    Validating architecture..."
        validateDllArchitecture(mainDll)

        // Copy extension DLL with proper naming
        def destDll = new File(phpPrepPath, "ext/php_${extName}.dll")
        destDll.parentFile.mkdirs()
        copy {
            from mainDll
            into destDll.parentFile
            // Rename to standard php_<extname>.dll format if needed
            if (mainDll.name != "php_${extName}.dll") {
                rename { "php_${extName}.dll" }
            }
        }
        println "    Copied: ${destDll.name} (from ${mainDll.name})"

        // Handle special cases (e.g., imagick)
        if (extName == 'imagick') {
            def imagickDir = new File(phpPrepPath, 'imagick')
            imagickDir.mkdirs()
            copy {
                from extDir
                into imagickDir
                include 'CORE_*.dll'
            }
        }

        // Add to extensions list (except xdebug)
        if (extName != 'xdebug') {
            extensionsText.append("extension=${extName}\n")
        }
    }

    // Update php.ini with extensions - replace @PHP_EXTENSIONS@ placeholder
    def phpIniFile = new File(phpPrepPath, 'php.ini')
    if (phpIniFile.exists()) {
        def phpIniContent = phpIniFile.text
        
        // Replace the @PHP_EXTENSIONS@ placeholder with actual extension entries
        if (phpIniContent.contains('@PHP_EXTENSIONS@')) {
            phpIniContent = phpIniContent.replace('@PHP_EXTENSIONS@', extensionsText.toString())
            phpIniFile.text = phpIniContent
            println "  Updated php.ini with ${exts.size()} extensions"
        } else {
            println "  WARNING: @PHP_EXTENSIONS@ placeholder not found in php.ini"
            println "  Extensions may need to be added manually"
        }
    } else {
        println "  WARNING: php.ini not found at ${phpIniFile}"
    }
}

// Helper: Validate DLL architecture (uses ProcessBuilder instead of exec)
def validateDllArchitecture(File dll) {
    // Use single quotes in PowerShell to avoid variable expansion issues
    def dllPath = dll.absolutePath.replace('\\', '\\\\')
    def psCommand = """
try {
    \$dllPath = '${dllPath}'
    if (-not (Test-Path \$dllPath)) {
        Write-Output 'Error: File not found'
        exit 1
    }
    \$bytes = [System.IO.File]::ReadAllBytes(\$dllPath)
    if (\$bytes.Length -lt 64) {
        Write-Output 'Error: File too small to be a valid DLL'
        exit 1
    }
    \$peOffset = [System.BitConverter]::ToInt32(\$bytes, 60)
    \$machineType = [System.BitConverter]::ToUInt16(\$bytes, \$peOffset + 4)
    if (\$machineType -eq 0x8664) {
        Write-Output '64-bit'
    } elseif (\$machineType -eq 0x014c) {
        Write-Output '32-bit'
    } else {
        Write-Output "Unknown architecture: 0x\$(\$machineType.ToString('X4'))"
    }
} catch {
    Write-Output "Error: \$(\$_.Exception.Message)"
}
""".trim()

    def command = [
        'powershell.exe',
        '-NoLogo',
        '-NoProfile',
        '-Command',
        psCommand
    ]

    def process = new ProcessBuilder(command as String[])
        .redirectErrorStream(true)
        .start()

    def output = new StringBuilder()
    process.inputStream.eachLine { line ->
        output.append(line).append('\n')
    }

    def exitCode = process.waitFor()
    def result = output.toString().trim()

    if (!result.contains('64-bit')) {
        throw new GradleException("DLL ${dll.name} is not 64-bit architecture. Result: ${result}\nFile: ${dll.absolutePath}")
    }
}

// Helper: Process PEAR installation
def processPear(File pearFile, File phpPrepPath) {
    def pear = new Properties()
    pearFile.withInputStream { pear.load(it) }

    // Copy pear-install scripts
    def pearInstallDir = new File(phpPrepPath, 'pear-install')
    copy {
        from pearInstallPath
        into pearInstallDir
    }

    // Download PEAR archive (property key is 'pear', not 'phppear.pear')
    def pearUrl = pear.getProperty('pear')
    if (!pearUrl) {
        println "  [WARNING] PEAR URL not found in pear.properties"
        println "  Skipping PEAR installation"
        delete pearInstallDir
        return
    }

    println "  Downloading PEAR from: ${pearUrl}"
    def pearArchive = downloadFile(pearUrl, pearInstallDir)

    // Extract the archive (it's a .tgz file)
    println "  Extracting PEAR archive..."
    def extractDir = new File(pearInstallDir, 'extracted')
    extractDir.mkdirs()

    // Extract .tgz using tar (Windows 10+ has built-in tar support)
    def tarCommand = [
        'tar',
        '-xzf',
        pearArchive.absolutePath,
        '-C',
        extractDir.absolutePath
    ]

    def process = new ProcessBuilder(tarCommand as String[])
        .redirectErrorStream(true)
        .start()

    def output = new StringBuilder()
    process.inputStream.eachLine { line ->
        output.append(line).append('\n')
    }

    def exitCode = process.waitFor()
    if (exitCode != 0) {
        throw new GradleException("Failed to extract PEAR archive: ${output}")
    }

    // Find the .phar file in the extracted directory (it's in a subfolder)
    def pharFile = null
    extractDir.eachFileRecurse { file ->
        if (file.name.endsWith('.phar')) {
            pharFile = file
        }
    }

    if (!pharFile) {
        throw new GradleException("Could not find .phar file in PEAR archive")
    }

    println "  Found PEAR phar: ${pharFile.name}"

    // Copy the phar file to pear-install directory
    copy {
        from pharFile
        into pearInstallDir
        rename { 'install-pear-nozlib.phar' }
    }

    // Execute PEAR installation
    println "  Installing PEAR..."

    def pearCommand = [
        'cmd',
        '/c',
        'pear-install.bat'
    ]

    def pearProcess = new ProcessBuilder(pearCommand as String[])
        .directory(pearInstallDir)
        .redirectErrorStream(true)
        .start()

    def pearOutput = new StringBuilder()
    pearProcess.inputStream.eachLine { line ->
        println "    ${line}"
        pearOutput.append(line).append('\n')
    }

    def pearExitCode = pearProcess.waitFor()
    if (pearExitCode != 0) {
        throw new GradleException("PEAR installation failed with exit code: ${pearExitCode}\nOutput: ${pearOutput}")
    }

    // Cleanup
    delete pearInstallDir
    println "  PEAR installation completed"
}

// Helper: Process dependencies
def processDependencies(File depsFile, File phpPrepPath) {
    def deps = new Properties()
    depsFile.withInputStream { deps.load(it) }

    deps.each { key, url ->
        def depName = key.toString().replace('phpdeps.', '')
        println "  Processing dependency: ${depName}"

        // Download dependency
        def downloadDir = file("${buildTmpPath}/downloads/dep/${depName}")
        def depArchive = downloadFile(url.toString(), downloadDir)

        // Extract if needed
        def depDir = downloadDir
        if (depArchive.name.endsWith('.zip') || depArchive.name.endsWith('.7z')) {
            depDir = file("${downloadDir}/extracted")
            extractArchive(depArchive, depDir)
        }

        // Handle special cases
        if (depName == 'imagemagick') {
            def imagickDir = new File(phpPrepPath, 'imagick')
            imagickDir.mkdirs()
            copy {
                from depDir
                into imagickDir
                include '*.exe', '*.dll'
            }
            println "    Copied ImageMagick files"
        }
    }
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        def releasesFile = file('releases.properties')
        if (!releasesFile.exists()) {
            println "releases.properties not found"
            return
        }

        def releases = new Properties()
        releasesFile.withInputStream { releases.load(it) }

        println "\nAvailable PHP Releases:"
        println "-".multiply(80)
        releases.sort { it.key }.each { version, url ->
            println "  ${version.padRight(10)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${releases.size()}"
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        def archivedDir = file("${projectDir}/bin/archived")

        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        def inBin = binDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) && it.name != 'archived' }
            ?.collect { it.name.replace(bundleName, '') } ?: []

        def inArchived = archivedDir.exists() ? (archivedDir.listFiles()
            ?.findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            ?.collect { it.name.replace(bundleName, '') } ?: []) : []

        def allVersions = (inBin + inArchived).toSet().toList().sort { a, b ->
            def pa = a.split('\\.').collect { it as int }
            def pb = b.split('\\.').collect { it as int }
            for (int i = 0; i < Math.max(pa.size(), pb.size()); i++) {
                def ai = i < pa.size() ? pa[i] : 0
                def bi = i < pb.size() ? pb[i] : 0
                if (ai != bi) return ai <=> bi
            }
            return 0
        }

        println "\nAvailable ${bundleName} versions (index, version, location):"
        println "-".multiply(60)
        allVersions.eachWithIndex { v, idx ->
            def tag
            def inBinFlag = inBin.contains(v)
            def inArchivedFlag = inArchived.contains(v)
            if (inBinFlag && inArchivedFlag) {
                tag = "[bin + bin/archived]"
            } else if (inBinFlag) {
                tag = "[bin]"
            } else if (inArchivedFlag) {
                tag = "[bin/archived]"
            } else {
                tag = "[unknown]"
            }
            def indexStr = String.format('%2d', idx + 1)
            println "  ${indexStr}. ${v.padRight(12)} ${tag}"
        }
        println "-".multiply(60)
        println "Total versions: ${allVersions.size()}"
        if (!allVersions.isEmpty()) {
            println "\nTo build a specific version:"
            println "  gradle release -PbundleVersion=${allVersions.last()}"
        }
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println "Validating build.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: List PHP extensions to be built
tasks.register('listExtensions') {
    group = 'help'
    description = 'List PHP extensions configured in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for PHP extension configurations..."
        println "=".multiply(80)

        def foundExtensions = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def extsFile = new File(versionDir, 'exts.properties')
                if (extsFile.exists()) {
                    foundExtensions = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def exts = new Properties()
                    extsFile.withInputStream { exts.load(it) }

                    exts.sort { it.key }.each { ext, url ->
                        def extName = ext.toString().replace('phpexts.', '')
                        println "  ${extName.padRight(20)} -> ${url}"
                    }
                }
            }

        if (!foundExtensions) {
            println "No extension configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: List PEAR configurations
tasks.register('listPearConfig') {
    group = 'help'
    description = 'List PEAR configurations in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for PEAR configurations..."
        println "=".multiply(80)

        def foundPear = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def pearFile = new File(versionDir, 'pear.properties')
                if (pearFile.exists()) {
                    foundPear = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def pear = new Properties()
                    pearFile.withInputStream { pear.load(it) }

                    pear.each { key, value ->
                        println "  ${key.toString().padRight(20)} -> ${value}"
                    }
                }
            }

        if (!foundPear) {
            println "No PEAR configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: List dependencies
tasks.register('listDependencies') {
    group = 'help'
    description = 'List dependencies configured in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for dependency configurations..."
        println "=".multiply(80)

        def foundDeps = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def depsFile = new File(versionDir, 'deps.properties')
                if (depsFile.exists()) {
                    foundDeps = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def deps = new Properties()
                    depsFile.withInputStream { deps.load(it) }

                    deps.sort { it.key }.each { dep, url ->
                        def depName = dep.toString().replace('phpdeps.', '')
                        println "  ${depName.padRight(20)} -> ${url}"
                    }
                }
            }

        if (!foundDeps) {
            println "No dependency configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: Show PHP-specific build information
tasks.register('phpInfo') {
    group = 'help'
    description = 'Display PHP-specific build information'

    doLast {
        println """
        ================================================================
                  PHP Module Build - Specific Information
        ================================================================

        This module includes special build processes for:

        1. PHP Extensions (exts.properties)
           - Downloads and integrates PHP extensions
           - Validates extensions with architecture check
           - Automatically updates php.ini

        2. PEAR Installation (pear.properties)
           - Installs PEAR package manager
           - Configures PEAR for the PHP version

        3. Dependencies (deps.properties)
           - Downloads required dependencies (e.g., ImageMagick)
           - Integrates dependencies into the build

        4. Architecture Verification
           - Verifies digital signatures of extensions
           - Ensures 64-bit compatibility

        Configuration Files:
          - exts.properties    : PHP extensions to include
          - pear.properties    : PEAR installation config
          - deps.properties    : External dependencies

        Useful Commands:
          gradle listExtensions     - Show configured extensions
          gradle listPearConfig     - Show PEAR configurations
          gradle listDependencies   - Show dependencies
          gradle validateDllArchitecture -PdllFile=<path> - Verify DLL
        """.stripIndent()
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module PHP - Pure Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
