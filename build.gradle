/*
 * Bearsampp Module PHP - Pure Gradle Build
 *
 * This is a pure Gradle build configuration that replaces the legacy Ant build system.
 * All build logic has been converted to native Gradle tasks.
 *
 * Usage:
 *   gradle tasks                              - List all available tasks
 *   gradle release                            - Interactive release (prompts for version)
 *   gradle release -PbundleVersion=8.3.15     - Non-interactive release
 *   gradle clean                              - Clean build artifacts
 *   gradle info                               - Display build information
 *   gradle verify                             - Verify build environment
 */

plugins {
    id 'base'
}

// Load build properties
def buildProps = new Properties()
file('build.properties').withInputStream { buildProps.load(it) }

// Project information
group = 'com.bearsampp.modules'
version = buildProps.getProperty('bundle.release', '1.0.0')
description = "Bearsampp Module - ${buildProps.getProperty('bundle.name', 'php')}"

// Define project paths
ext {
    projectBasedir = projectDir.absolutePath
    rootDir = projectDir.parent
    devPath = file("${rootDir}/dev").absolutePath
    buildPropertiesFile = file('build.properties').absolutePath

    // Bundle properties from build.properties
    bundleName = buildProps.getProperty('bundle.name', 'php')
    bundleRelease = buildProps.getProperty('bundle.release', '1.0.0')
    bundleType = buildProps.getProperty('bundle.type', 'bins')
    bundleFormat = buildProps.getProperty('bundle.format', '7z')

    // PHP-specific paths
    phpExtPath = file("${projectDir}/ext").absolutePath
    pearInstallPath = file("${projectDir}/pear").absolutePath
    bundleTmpPrepPath = file("${projectDir}/tmp/prep").absolutePath
    buildTmpPath = file("${projectDir}/tmp").absolutePath
}

// Verify dev path exists
if (!file(ext.devPath).exists()) {
    logger.warn("Dev path not found: ${ext.devPath}. Some tasks may not work correctly.")
}

// Configure repositories for dependencies
repositories {
    mavenCentral()
}

// ============================================================================
// GRADLE NATIVE TASKS - Pure Gradle Implementation
// ============================================================================

// Task: Display build information
tasks.register('info') {
    group = 'help'
    description = 'Display build configuration information'

    // Capture values at configuration time to avoid deprecation warnings
    def projectName = project.name
    def projectVersion = project.version
    def projectDescription = project.description
    def gradleVersion = gradle.gradleVersion
    def gradleHome = gradle.gradleHomeDir

    doLast {
        println """
        ================================================================
                  Bearsampp Module PHP - Build Info
        ================================================================

        Project:        ${projectName}
        Version:        ${projectVersion}
        Description:    ${projectDescription}

        Bundle Properties:
          Name:         ${bundleName}
          Release:      ${bundleRelease}
          Type:         ${bundleType}
          Format:       ${bundleFormat}

        Paths:
          Project Dir:  ${projectBasedir}
          Root Dir:     ${rootDir}
          Dev Path:     ${devPath}
          PHP Ext:      ${phpExtPath}
          PEAR Install: ${pearInstallPath}

        Java:
          Version:      ${JavaVersion.current()}
          Home:         ${System.getProperty('java.home')}

        Gradle:
          Version:      ${gradleVersion}
          Home:         ${gradleHome}

        Available Task Groups:
          * build        - Build and package tasks
          * help         - Help and information tasks
          * verification - Verification and validation tasks

        Quick Start:
          gradle tasks                          - List all available tasks
          gradle info                           - Show this information
          gradle release                        - Interactive release build
          gradle release -PbundleVersion=8.3.15 - Non-interactive release
          gradle clean                          - Clean build artifacts
          gradle verify                         - Verify build environment
          gradle listExtensions                 - List PHP extensions to build
        """.stripIndent()
    }
}

// Task: Enhanced clean task
tasks.named('clean') {
    group = 'build'
    description = 'Clean build artifacts and temporary files'

    doLast {
        // Clean Gradle build directory
        def buildDir = file("${projectDir}/build")
        if (buildDir.exists()) {
            delete buildDir
            println "Cleaned: ${buildDir}"
        }

        // Clean temporary directories
        def tmpDir = file(buildTmpPath)
        if (tmpDir.exists()) {
            delete tmpDir
            println "Cleaned: ${tmpDir}"
        }

        println "[SUCCESS] Build artifacts cleaned"
    }
}

// Task: Verify build environment
tasks.register('verify') {
    group = 'verification'
    description = 'Verify build environment and dependencies'

    doLast {
        println "Verifying build environment for module-php..."

        def checks = [:]

        // Check Java version
        def javaVersion = JavaVersion.current()
        checks['Java 8+'] = javaVersion >= JavaVersion.VERSION_1_8

        // Check required files
        checks['build.properties'] = file('build.properties').exists()
        checks['releases.properties'] = file('releases.properties').exists()

        // Check PHP-specific directories
        checks['pear directory'] = file(pearInstallPath).exists()
        checks['pear-install.bat'] = file("${pearInstallPath}/pear-install.bat").exists()

        // Check bin directory
        checks['bin directory'] = file("${projectDir}/bin").exists()

        println "\nEnvironment Check Results:"
        println "-".multiply(60)
        checks.each { name, passed ->
            def status = passed ? "[PASS]" : "[FAIL]"
            println "  ${status.padRight(10)} ${name}"
        }
        println "-".multiply(60)

        def allPassed = checks.values().every { it }
        if (allPassed) {
            println "\n[SUCCESS] All checks passed! Build environment is ready."
            println "\nYou can now run:"
            println "  gradle release                        - Interactive release"
            println "  gradle release -PbundleVersion=8.3.15 - Non-interactive release"
        } else {
            println "\n[WARNING] Some checks failed. Please review the requirements."
            throw new GradleException("Build environment verification failed")
        }
    }
}

// Task: Validate architecture of DLL files
tasks.register('validateDllArchitecture') {
    group = 'verification'
    description = 'Validate DLL architecture (64-bit check)'

    doLast {
        def dllFile = project.findProperty('dllFile')
        if (!dllFile) {
            throw new GradleException("Please specify -PdllFile=<path> to validate")
        }

        def dll = file(dllFile)
        if (!dll.exists()) {
            throw new GradleException("DLL file not found: ${dllFile}")
        }

        println "Validating architecture for: ${dll.name}"

        def outputFile = file("${buildTmpPath}/sigcheck_output.txt")
        outputFile.parentFile.mkdirs()

        def psCommand = """
try {
    \$bytes = [System.IO.File]::ReadAllBytes('${dll.absolutePath}');
    \$peOffset = [System.BitConverter]::ToInt32(\$bytes, 60);
    \$machineType = [System.BitConverter]::ToUInt16(\$bytes, \$peOffset + 4);
    if (\$machineType -eq 0x8664) {
        Write-Output 'MachineType: 64-bit'
    } elseif (\$machineType -eq 0x014c) {
        Write-Output 'MachineType: 32-bit'
    } else {
        Write-Output 'MachineType: Unknown'
    }
} catch {
    Write-Output 'MachineType: Error'
}
""".trim()

        def result = exec {
            executable 'powershell.exe'
            args '-NoLogo', '-NoProfile', '-Command', psCommand
            standardOutput = new ByteArrayOutputStream()
            ignoreExitValue = true
        }

        def output = result.standardOutput.toString().trim()
        println output

        if (!output.contains('64-bit')) {
            throw new GradleException("DLL ${dll.name} is not 64-bit architecture. Build halted.")
        }

        println "[SUCCESS] DLL is 64-bit compatible"
    }
}

// Task: Download file helper
def downloadFile(String url, File destDir) {
    def fileName = url.tokenize('/').last()
    def destFile = new File(destDir, fileName)

    if (!destFile.exists()) {
        println "Downloading: ${url}"
        destFile.parentFile.mkdirs()

        new URL(url).withInputStream { input ->
            destFile.withOutputStream { output ->
                output << input
            }
        }
        println "Downloaded to: ${destFile}"
    } else {
        println "Already exists: ${destFile}"
    }

    return destFile
}

// Task: Extract archive helper
def extractArchive(File archive, File destDir) {
    destDir.mkdirs()

    if (archive.name.endsWith('.zip')) {
        copy {
            from zipTree(archive)
            into destDir
        }
    } else if (archive.name.endsWith('.7z')) {
        exec {
            executable '7z'
            args 'x', archive.absolutePath, "-o${destDir.absolutePath}", '-y'
        }
    }

    println "Extracted to: ${destDir}"
}

// Task: Main release task
tasks.register('release') {
    group = 'build'
    description = 'Build release package (interactive or use -PbundleVersion=X.X.X for non-interactive)'

    doLast {
        def versionToBuild = project.findProperty('bundleVersion')

        if (!versionToBuild) {
            // Interactive mode - prompt for version
            println "=".multiply(70)
            println "Available PHP versions in bin/:"
            println "-".multiply(70)

            def binDir = file("${projectDir}/bin")
            def versions = binDir.listFiles()
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                .collect { it.name.replace(bundleName, '') }
                .sort()

            versions.each { version ->
                println "  ${version}"
            }
            println "-".multiply(70)

            print "\nEnter bundle version to build: "
            System.out.flush()

            def reader = new BufferedReader(new InputStreamReader(System.in))
            versionToBuild = reader.readLine()?.trim()

            if (!versionToBuild) {
                throw new GradleException("No version specified")
            }
        }

        println "=".multiply(70)
        println "Building release for ${bundleName} version ${versionToBuild}..."
        println "=".multiply(70)

        def bundlePath = file("${projectDir}/bin/${bundleName}${versionToBuild}")

        if (!bundlePath.exists()) {
            def availableVersions = file("${projectDir}/bin").listFiles()
                .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
                .collect { "  - " + it.name.replace(bundleName, '') }
                .join('\n')

            throw new GradleException("Bundle version not found: ${bundlePath}\n\nAvailable versions in bin/:\n${availableVersions}")
        }

        println "Bundle path: ${bundlePath}"
        println ""

        // Execute the release build
        tasks.getByName('releaseBuild').execute()
    }
}

// Task: Actual release build logic
tasks.register('releaseBuild') {
    group = 'build'
    description = 'Execute the release build process'

    doLast {
        def versionToBuild = project.findProperty('bundleVersion')
        if (!versionToBuild) {
            throw new GradleException("bundleVersion property not set")
        }

        def bundlePath = file("${projectDir}/bin/${bundleName}${versionToBuild}")
        def bundleFolder = bundlePath.name
        def bundleVersion = bundleFolder.replace(bundleName, '')

        println "Processing bundle: ${bundleFolder}"
        println "Version: ${bundleVersion}"

        // Prepare PHP directory
        def phpPrepPath = file("${bundleTmpPrepPath}/${bundleFolder}")
        delete phpPrepPath
        phpPrepPath.mkdirs()

        println "Preparation path: ${phpPrepPath}"

        // Copy base PHP files
        println "Copying base PHP files..."
        copy {
            from bundlePath
            into phpPrepPath
            exclude 'dev/**', 'extras/**', 'PEAR/**', '*.reg', 'install.txt',
                    'go-pear.bat', 'news.txt', 'php.gif', 'php.ini*', 'snapshot.txt'
        }

        // Process extensions if exts.properties exists
        def extsFile = new File(bundlePath, 'exts.properties')
        if (extsFile.exists()) {
            println "Processing extensions..."
            processExtensions(extsFile, phpPrepPath)
        }

        // Process PEAR if pear.properties exists
        def pearFile = new File(bundlePath, 'pear.properties')
        if (pearFile.exists()) {
            println "Processing PEAR installation..."
            processPear(pearFile, phpPrepPath)
        }

        // Process dependencies if deps.properties exists
        def depsFile = new File(bundlePath, 'deps.properties')
        if (depsFile.exists()) {
            println "Processing dependencies..."
            processDependencies(depsFile, phpPrepPath)
        }

        println ""
        println "=".multiply(70)
        println "[SUCCESS] Release build completed successfully for version ${versionToBuild}"
        println "Output: ${phpPrepPath}"
        println "=".multiply(70)
    }
}

// Helper: Process PHP extensions
def processExtensions(File extsFile, File phpPrepPath) {
    def exts = new Properties()
    extsFile.withInputStream { exts.load(it) }

    def extensionsText = new StringBuilder()
    def tmpExtFile = file("${buildTmpPath}/php_extensions.tmp")
    tmpExtFile.parentFile.mkdirs()
    tmpExtFile.text = ""

    exts.each { key, url ->
        def extName = key.toString().replace('phpexts.', '')
        println "  Processing extension: ${extName}"

        // Download extension
        def downloadDir = file("${buildTmpPath}/downloads/ext/${extName}")
        def extArchive = downloadFile(url.toString(), downloadDir)

        // Extract if needed
        def extDir = downloadDir
        if (extArchive.name.endsWith('.zip') || extArchive.name.endsWith('.7z')) {
            extDir = file("${downloadDir}/extracted")
            extractArchive(extArchive, extDir)
        }

        // Find the main DLL
        def mainDll = null
        extDir.eachFileRecurse { file ->
            if (file.name == "php_${extName}.dll") {
                mainDll = file
            }
        }

        if (!mainDll) {
            throw new GradleException("Main DLL not found for extension: ${extName}")
        }

        // Validate architecture
        println "    Validating architecture..."
        validateDllArchitecture(mainDll)

        // Copy extension DLL
        def destDll = new File(phpPrepPath, "ext/php_${extName}.dll")
        destDll.parentFile.mkdirs()
        copy {
            from mainDll
            into destDll.parentFile
        }
        println "    Copied: ${destDll.name}"

        // Handle special cases (e.g., imagick)
        if (extName == 'imagick') {
            def imagickDir = new File(phpPrepPath, 'imagick')
            imagickDir.mkdirs()
            copy {
                from extDir
                into imagickDir
                include 'CORE_*.dll'
            }
        }

        // Add to extensions list (except xdebug)
        if (extName != 'xdebug') {
            extensionsText.append("extension=${extName}\n")
        }
    }

    // Update php.ini with extensions
    def phpIniTemplate = new File(phpPrepPath.parentFile.parentFile.parentFile, "bin/${phpPrepPath.name}/php.ini")
    if (phpIniTemplate.exists()) {
        def phpIniContent = phpIniTemplate.text
        phpIniContent = phpIniContent.replace('@PHP_EXTENSIONS@', extensionsText.toString())

        def phpIniDest = new File(phpPrepPath, 'php.ini')
        phpIniDest.text = phpIniContent
        println "  Updated php.ini with extensions"
    }
}

// Helper: Validate DLL architecture
def validateDllArchitecture(File dll) {
    def psCommand = """
try {
    \$bytes = [System.IO.File]::ReadAllBytes('${dll.absolutePath.replace('\\', '\\\\')}');
    \$peOffset = [System.BitConverter]::ToInt32(\$bytes, 60);
    \$machineType = [System.BitConverter]::ToUInt16(\$bytes, \$peOffset + 4);
    if (\$machineType -eq 0x8664) {
        Write-Output '64-bit'
    } elseif (\$machineType -eq 0x014c) {
        Write-Output '32-bit'
    } else {
        Write-Output 'Unknown'
    }
} catch {
    Write-Output 'Error'
}
""".trim()

    def output = new ByteArrayOutputStream()
    exec {
        executable 'powershell.exe'
        args '-NoLogo', '-NoProfile', '-Command', psCommand
        standardOutput = output
        ignoreExitValue = false
    }

    def result = output.toString().trim()
    if (!result.contains('64-bit')) {
        throw new GradleException("DLL ${dll.name} is not 64-bit architecture")
    }
}

// Helper: Process PEAR installation
def processPear(File pearFile, File phpPrepPath) {
    def pear = new Properties()
    pearFile.withInputStream { pear.load(it) }

    // Copy pear-install scripts
    def pearInstallDir = new File(phpPrepPath, 'pear-install')
    copy {
        from pearInstallPath
        into pearInstallDir
    }

    // Download PEAR phar
    def pearUrl = pear.getProperty('phppear.pear')
    def pearPhar = downloadFile(pearUrl, pearInstallDir)

    copy {
        from pearPhar
        into pearInstallDir
        rename { 'install-pear-nozlib.phar' }
    }

    // Execute PEAR installation
    println "  Installing PEAR..."
    exec {
        executable 'cmd'
        args '/c', 'pear-install.bat'
        workingDir pearInstallDir
    }

    // Cleanup
    delete pearInstallDir
    println "  PEAR installation completed"
}

// Helper: Process dependencies
def processDependencies(File depsFile, File phpPrepPath) {
    def deps = new Properties()
    depsFile.withInputStream { deps.load(it) }

    deps.each { key, url ->
        def depName = key.toString().replace('phpdeps.', '')
        println "  Processing dependency: ${depName}"

        // Download dependency
        def downloadDir = file("${buildTmpPath}/downloads/dep/${depName}")
        def depArchive = downloadFile(url.toString(), downloadDir)

        // Extract if needed
        def depDir = downloadDir
        if (depArchive.name.endsWith('.zip') || depArchive.name.endsWith('.7z')) {
            depDir = file("${downloadDir}/extracted")
            extractArchive(depArchive, depDir)
        }

        // Handle special cases
        if (depName == 'imagemagick') {
            def imagickDir = new File(phpPrepPath, 'imagick')
            imagickDir.mkdirs()
            copy {
                from depDir
                into imagickDir
                include '*.exe', '*.dll'
            }
            println "    Copied ImageMagick files"
        }
    }
}

// Task: List all bundle versions from releases.properties
tasks.register('listReleases') {
    group = 'help'
    description = 'List all available releases from releases.properties'

    doLast {
        def releasesFile = file('releases.properties')
        if (!releasesFile.exists()) {
            println "releases.properties not found"
            return
        }

        def releases = new Properties()
        releasesFile.withInputStream { releases.load(it) }

        println "\nAvailable PHP Releases:"
        println "-".multiply(80)
        releases.sort { it.key }.each { version, url ->
            println "  ${version.padRight(10)} -> ${url}"
        }
        println "-".multiply(80)
        println "Total releases: ${releases.size()}"
    }
}

// Task: List available bundle versions in bin directory
tasks.register('listVersions') {
    group = 'help'
    description = 'List all available bundle versions in bin/ directory'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        def versions = binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .collect { it.name.replace(bundleName, '') }
            .sort()

        println "\nAvailable ${bundleName} versions in bin/:"
        println "-".multiply(60)
        versions.each { version ->
            println "  ${version}"
        }
        println "-".multiply(60)
        println "Total versions: ${versions.size()}"
        println "\nTo build a specific version:"
        println "  gradle release -PbundleVersion=${versions.last()}"
    }
}

// Task: Validate build.properties
tasks.register('validateProperties') {
    group = 'verification'
    description = 'Validate build.properties configuration'

    doLast {
        println "Validating build.properties..."

        def required = ['bundle.name', 'bundle.release', 'bundle.type', 'bundle.format']
        def missing = []

        required.each { prop ->
            if (!buildProps.containsKey(prop) || buildProps.getProperty(prop).trim().isEmpty()) {
                missing.add(prop)
            }
        }

        if (missing.isEmpty()) {
            println "[SUCCESS] All required properties are present:"
            required.each { prop ->
                println "    ${prop} = ${buildProps.getProperty(prop)}"
            }
        } else {
            println "[ERROR] Missing required properties:"
            missing.each { prop ->
                println "    - ${prop}"
            }
            throw new GradleException("build.properties validation failed")
        }
    }
}

// Task: List PHP extensions to be built
tasks.register('listExtensions') {
    group = 'help'
    description = 'List PHP extensions configured in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for PHP extension configurations..."
        println "=".multiply(80)

        def foundExtensions = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def extsFile = new File(versionDir, 'exts.properties')
                if (extsFile.exists()) {
                    foundExtensions = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def exts = new Properties()
                    extsFile.withInputStream { exts.load(it) }

                    exts.sort { it.key }.each { ext, url ->
                        def extName = ext.toString().replace('phpexts.', '')
                        println "  ${extName.padRight(20)} -> ${url}"
                    }
                }
            }

        if (!foundExtensions) {
            println "No extension configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: List PEAR configurations
tasks.register('listPearConfig') {
    group = 'help'
    description = 'List PEAR configurations in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for PEAR configurations..."
        println "=".multiply(80)

        def foundPear = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def pearFile = new File(versionDir, 'pear.properties')
                if (pearFile.exists()) {
                    foundPear = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def pear = new Properties()
                    pearFile.withInputStream { pear.load(it) }

                    pear.each { key, value ->
                        println "  ${key.toString().padRight(20)} -> ${value}"
                    }
                }
            }

        if (!foundPear) {
            println "No PEAR configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: List dependencies
tasks.register('listDependencies') {
    group = 'help'
    description = 'List dependencies configured in bin directories'

    doLast {
        def binDir = file("${projectDir}/bin")
        if (!binDir.exists()) {
            println "bin/ directory not found"
            return
        }

        println "\nScanning for dependency configurations..."
        println "=".multiply(80)

        def foundDeps = false
        binDir.listFiles()
            .findAll { it.isDirectory() && it.name.startsWith(bundleName) }
            .sort { it.name }
            .each { versionDir ->
                def depsFile = new File(versionDir, 'deps.properties')
                if (depsFile.exists()) {
                    foundDeps = true
                    def version = versionDir.name.replace(bundleName, '')
                    println "\nPHP ${version}:"
                    println "-".multiply(80)

                    def deps = new Properties()
                    depsFile.withInputStream { deps.load(it) }

                    deps.sort { it.key }.each { dep, url ->
                        def depName = dep.toString().replace('phpdeps.', '')
                        println "  ${depName.padRight(20)} -> ${url}"
                    }
                }
            }

        if (!foundDeps) {
            println "No dependency configurations found in bin/ directories"
        }
        println "=".multiply(80)
    }
}

// Task: Show PHP-specific build information
tasks.register('phpInfo') {
    group = 'help'
    description = 'Display PHP-specific build information'

    doLast {
        println """
        ================================================================
                  PHP Module Build - Specific Information
        ================================================================

        This module includes special build processes for:

        1. PHP Extensions (exts.properties)
           - Downloads and integrates PHP extensions
           - Validates extensions with architecture check
           - Automatically updates php.ini

        2. PEAR Installation (pear.properties)
           - Installs PEAR package manager
           - Configures PEAR for the PHP version

        3. Dependencies (deps.properties)
           - Downloads required dependencies (e.g., ImageMagick)
           - Integrates dependencies into the build

        4. Architecture Verification
           - Verifies digital signatures of extensions
           - Ensures 64-bit compatibility

        Configuration Files:
          - exts.properties    : PHP extensions to include
          - pear.properties    : PEAR installation config
          - deps.properties    : External dependencies

        Useful Commands:
          gradle listExtensions     - Show configured extensions
          gradle listPearConfig     - Show PEAR configurations
          gradle listDependencies   - Show dependencies
          gradle validateDllArchitecture -PdllFile=<path> - Verify DLL
        """.stripIndent()
    }
}

// ============================================================================
// BUILD LIFECYCLE HOOKS
// ============================================================================

gradle.taskGraph.whenReady { graph ->
    println """
    ================================================================
      Bearsampp Module PHP - Pure Gradle Build
    ================================================================
    """.stripIndent()
}

// ============================================================================
// DEFAULT TASK
// ============================================================================

defaultTasks 'info'
